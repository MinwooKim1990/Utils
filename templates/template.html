<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minwoo의 파일 탐색기</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <!-- Add Marked.js library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add DOMPurify library for sanitization -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>
</head>
<body>
    <div class="sidebar">
      <div class="drive-selector">
        {% for drv in allowed_drives %}
          <a href="/?drive={{ drv }}&api_key={{ api_key }}" class="{% if drv == drive %}selected{% endif %}">{{ drv[:-2] }}</a>
        {% endfor %}
      </div>
      <h4>📁 탐색기</h4>
      <div class="tree">
        {{ tree_html|safe }}
      </div>
    </div>
    <div class="content">
      <div class="top-bar">
        <div class="nav-buttons">
          <button onclick="goBack()">⏪ 뒤로</button>
          <button onclick="goForward()">⏩ 앞으로</button>
        </div>
        <div class="search-bar">
          🔍 <input type="text" id="searchInput" oninput="searchFiles()" placeholder="파일명 검색...">
        </div>
        <div class="sort-buttons">
          <span>정렬:</span>
          {% set opposite_dir = 'desc' if sort_dir == 'asc' else 'asc' %}
          {% set name_dir = opposite_dir if sort_param == 'name' else 'asc' %}
          {% set date_dir = opposite_dir if sort_param == 'date' else 'asc' %}
          {% set size_dir = opposite_dir if sort_param == 'size' else 'asc' %}
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=name&dir={{ name_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'name' %}selected{% endif %}">
             이름 {% if sort_param == 'name' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=date&dir={{ date_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'date' %}selected{% endif %}">
             날짜 {% if sort_param == 'date' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=size&dir={{ size_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'size' %}selected{% endif %}">
             크기 {% if sort_param == 'size' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
        </div>
      </div>
      <div class="location-bar">
        <h3>📂 현재 위치 (드라이브: {{ drive[:-2] }}): {{ current_path or '/' }}</h3>
      </div>

      <!-- New Wrapper for File List and Chat -->
      <div class="content-wrapper">
        <!-- Existing File Content Area -->
        <div class="main-content">
            <div id="file-list" class="file-list">
                {% if is_search %}
                    <h2>Search Results for "{{ search_query }}" in {{ current_path or 'root' }}</h2>
                    {% include 'search_results.html' %}
                {% else %}
                    <h2>Files in {{ current_path or 'root' }}</h2>
                    {% include 'file_list.html' %}
                {% endif %}
            </div>
            <!-- 드래그 앤 드롭 업로드 영역 -->
            <div id="drop-area">
                <p>파일을 여기에 끌어다 놓으세요.</p>
                <p>또는 아래 버튼을 사용하여 파일을 선택할 수 있습니다.</p>
                <form method="POST" action="/upload?drive={{ drive }}&api_key={{ api_key }}&path={{ current_path }}" enctype="multipart/form-data">
                    <input type="file" name="file">
                    <button type="submit">업로드</button>
                </form>
                <div id="upload-progress"></div>
            </div>
        </div>

        <!-- New Chat Interface Area -->
        <div id="chat-container">
            <div id="chat-header">
                <h4>💬 Gemini Chat</h4>
                <button id="refresh-chat-button" title="새 대화 시작">🔄</button>
            </div>
            <!-- Model Selector Dropdown -->
            <div class="model-selector">
                <label for="model-select">모델 선택:</label>
                <select id="model-select">
                    <option value="gemini-2.0-flash-lite" selected>gemini-2.0-flash-lite</option>
                    <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                    <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                </select>
            </div>
            <div id="chat-messages">
                <!-- Chat messages will appear here -->
            </div>
            <!-- Image preview area -->
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <span id="image-filename"></span>
                <button id="remove-image-button" title="이미지 제거">&times;</button>
            </div>
            <!-- Mic status indicator -->
            <span id="mic-status"></span>
            <div id="chat-input-area">
                <!-- Hidden file input -->
                <input type="file" id="image-upload" accept="image/*">
                <!-- Image upload button -->
                <button id="image-upload-button" title="이미지 첨부">🖼️</button>
                <!-- Mic button -->
                <button id="mic-button" title="음성 입력">🎤</button>
                <input type="text" id="chat-input" placeholder="메시지를 입력하세요...">
                <button id="send-button">전송</button>
            </div>
        </div>
      </div>
      <!-- End New Wrapper -->

    </div> <!-- End .content -->

    <!-- Preview Modal Overlay -->
    <div id="preview-overlay" style="display: none;">
      <button id="preview-close-btn">&times;</button>
      <div id="preview-content">
          <!-- Add video element here -->
          <video id="preview-video" controls style="display: none; max-width: 100%; max-height: 80vh;"></video>
          <!-- Existing preview elements might be here, ensure they are hidden when video shows -->
          <img id="preview-image" style="display: none; max-width: 100%; max-height: 80vh;" />
          <pre id="preview-text" style="display: none; white-space: pre-wrap; word-wrap: break-word;"></pre>
          <div id="preview-pdf" style="display: none; width: 100%; height: 80vh;"></div>
          <!-- Add other preview types if needed -->
      </div>
      <div id="preview-filename"></div>
    </div>

    <script>
      // --- Preview Modal Elements (For Preview-Only Files) --- START
      const previewOverlay = document.getElementById('preview-overlay');
      const previewContent = document.getElementById('preview-content');
      const previewCloseBtn = document.getElementById('preview-close-btn');
      const previewFilename = document.getElementById('preview-filename');
      // --- Preview Modal Elements --- END

      // --- Preview Modal Functions (For Preview-Only Files) --- START
      function showPreviewModal(fileType, url, fileName) {
          if (!previewOverlay || !previewContent || !previewFilename || !previewCloseBtn) { console.error("Preview modal elements missing."); alert("Preview error."); return; }
          previewContent.innerHTML = '<span class="preview-placeholder">Loading preview...</span>';
          previewFilename.textContent = fileName;
          let element;
          if (fileType === 'video') { element = document.createElement('video'); element.controls = true; element.autoplay = true; element.style.maxWidth = '90vw'; element.style.maxHeight = '80vh'; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Video load failed.</p>'; }; }
          else if (fileType === 'audio') { element = document.createElement('audio'); element.controls = true; element.autoplay = true; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Audio load failed.</p>'; }; }
          else if (fileType === 'image') { element = document.createElement('img'); element.style.maxWidth = '90vw'; element.style.maxHeight = '80vh'; element.style.display = 'block'; element.style.margin = 'auto'; element.alt = fileName; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Image load failed.</p>'; }; }
          else if (fileType === 'text' || fileType === 'pdf') { element = document.createElement('iframe'); element.style.width = '90vw'; element.style.height = '80vh'; element.style.border = 'none'; element.style.backgroundColor = 'var(--card, #fff)'; element.src = url; element.onload = () => console.log("Modal iframe loaded."); element.onerror = () => { previewContent.innerHTML = '<p>Preview load failed.</p>'; }; }
          if (element) { previewContent.innerHTML = ''; previewContent.appendChild(element); previewOverlay.style.display = 'flex'; }
          else { console.error("Could not create preview element for type:", fileType); previewContent.innerHTML = '<p>Cannot create preview element.</p>'; previewOverlay.style.display = 'flex'; }
      }
      function closePreviewModal() { if (!previewOverlay || !previewContent) return; previewOverlay.style.display = 'none'; const media = previewContent.querySelector('video, audio'); if (media) { media.pause(); media.src = ''; } const iframe = previewContent.querySelector('iframe'); if (iframe) iframe.src = 'about:blank'; previewContent.innerHTML = ''; if (previewFilename) previewFilename.textContent = ''; }
      if (previewCloseBtn) previewCloseBtn.addEventListener('click', closePreviewModal);
      if (previewOverlay) previewOverlay.addEventListener('click', function(e) { if (e.target === previewOverlay) closePreviewModal(); });
      // --- Preview Modal Functions --- END

      // --- Global Variables & Initial Setup ---
      const MAX_HISTORY_LENGTH = 10;
      const fileChatInstances = {};
      let instanceCounter = 0;

      // --- DOM Element References (Main Chat) ---
      const mainChatContainer = document.getElementById('chat-container');
      const mainChatMessages = document.getElementById('chat-messages');
      const mainChatInput = document.getElementById('chat-input');
      const mainSendButton = document.getElementById('send-button');
      const mainModelSelect = document.getElementById('model-select');
      const mainImageUploadButton = document.getElementById('image-upload-button');
      const mainImageUploadInput = document.getElementById('image-upload');
      const mainImagePreviewArea = document.getElementById('image-preview-area');
      const mainImagePreview = document.getElementById('image-preview');
      const mainImageFilename = document.getElementById('image-filename');
      const mainRemoveImageButton = document.getElementById('remove-image-button');
      const mainMicButton = document.getElementById('mic-button');
      const mainMicStatus = document.getElementById('mic-status');
      const mainRefreshChatButton = document.getElementById('refresh-chat-button');
      const fileListContainer = document.getElementById('file-list');

      // --- Main Chat History & State ---
      let mainChatHistory = [];
      let mainAttachedImageData = null;
      let mainMediaRecorder;
      let mainAudioChunks = [];
      let isMainRecording = false;

      // --- Mini Audio Player Logic --- START
      let miniPlayer = null;
      let miniPlayerAudio = null; // HTMLAudioElement
      let miniPlayerTitle = null;
      let miniPlayerPlayPauseBtn = null;
      let miniPlayerNextBtn = null;
      let miniPlayerPrevBtn = null;
      let miniPlayerCloseBtn = null;
      let miniPlayerProgress = null;
      let miniPlayerTime = null;
      let miniPlayerVolume = null; // <<< Volume slider element

      let audioPlaylist = []; // Array of {url: string, title: string}
      let currentTrackIndex = -1;
      let isMiniPlayerSeeking = false;

      // Function to save player state to localStorage
      function savePlayerState() {
          if (!miniPlayerAudio || audioPlaylist.length === 0 || currentTrackIndex < 0) {
               localStorage.removeItem('miniPlayerState'); // Clear if nothing is playing
               return;
           }
          const state = {
              playlist: audioPlaylist,
              index: currentTrackIndex,
              time: miniPlayerAudio.currentTime,
              volume: miniPlayerAudio.volume,
              paused: miniPlayerAudio.paused // Save paused state
          };
          try {
              localStorage.setItem('miniPlayerState', JSON.stringify(state));
          } catch (e) {
              console.error("Error saving player state to localStorage:", e);
          }
      }

      // Function to load player state from localStorage
      function loadPlayerState() {
          try {
              const savedState = localStorage.getItem('miniPlayerState');
              if (savedState) {
                  const state = JSON.parse(savedState);
                  // Basic validation
                  if (state && Array.isArray(state.playlist) && typeof state.index === 'number' && state.index >= 0 && state.index < state.playlist.length) {
                      audioPlaylist = state.playlist;
                      currentTrackIndex = state.index;

                      // Load the track but don't auto-play immediately from localStorage restore
                      const track = audioPlaylist[currentTrackIndex];
                       if(track && track.url) {
                            miniPlayerAudio.src = track.url;
                            miniPlayerTitle.textContent = track.title;
                            // Restore time only if duration is available (might need small delay or check in loadedmetadata)
                            miniPlayerAudio.addEventListener('loadedmetadata', () => {
                                if (!isNaN(miniPlayerAudio.duration) && state.time < miniPlayerAudio.duration) {
                                    miniPlayerAudio.currentTime = state.time;
                                }
                                miniPlayerProgress.max = miniPlayerAudio.duration || 100;
                                miniPlayerProgress.value = miniPlayerAudio.currentTime;
                                updatePlayerUI(); // Update UI after metadata loaded
                                // Restore paused state
                                if (state.paused) {
                                    miniPlayerAudio.pause();
            } else {
                                    // Optional: Auto-play if it wasn't paused? Decide based on desired UX
                                    // miniPlayerAudio.play().catch(e => console.error("Autoplay from restore failed:", e));
                                }
                                updatePlayerUI();
                            }, { once: true }); // Ensure listener only runs once per load

                            // Restore volume
                            if (typeof state.volume === 'number' && state.volume >= 0 && state.volume <= 1) {
                                miniPlayerAudio.volume = state.volume;
                                if (miniPlayerVolume) miniPlayerVolume.value = state.volume;
                            }

                            showMiniPlayer();
                            console.log("Restored player state from localStorage:", state);
                } else {
                           console.warn("Invalid track data in saved state.");
                           localStorage.removeItem('miniPlayerState');
                       }

                  } else {
                      console.log("Invalid saved player state found, clearing.");
                      localStorage.removeItem('miniPlayerState');
                  }
              } else {
                  console.log("No saved player state found.");
              }
          } catch (e) {
              console.error("Error loading player state from localStorage:", e);
              localStorage.removeItem('miniPlayerState'); // Clear corrupted state
          }
      }


      function formatTime(seconds) {
          const minutes = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
      }

      // ... other functions (savePlayerState, loadPlayerState, formatTime) ...

      function initMiniPlayer() {
          miniPlayer = document.getElementById('mini-audio-player');
          miniPlayerTitle = document.getElementById('mini-player-title');
          miniPlayerPlayPauseBtn = document.getElementById('mini-player-playpause');
          miniPlayerNextBtn = document.getElementById('mini-player-next');
          miniPlayerPrevBtn = document.getElementById('mini-player-prev');
          miniPlayerCloseBtn = document.getElementById('mini-player-close');
          miniPlayerProgress = document.getElementById('mini-player-progress');
          miniPlayerTime = document.getElementById('mini-player-time');
          miniPlayerVolume = document.getElementById('mini-player-volume'); // <<< Get volume slider

          if (!miniPlayer || !miniPlayerTitle || !miniPlayerPlayPauseBtn || !miniPlayerNextBtn || !miniPlayerCloseBtn || !miniPlayerProgress || !miniPlayerTime || !miniPlayerVolume) {
              console.error("Mini Player elements not found!");
              return;
          }

          miniPlayerAudio = new Audio();

          // Define named event handlers
          handleMiniPlayerLoadedMetadata = () => {
              if (!isNaN(miniPlayerAudio.duration)) {
                   miniPlayerProgress.max = miniPlayerAudio.duration;
                   updatePlayerUI();
              }
          };
          handleMiniPlayerTimeUpdate = () => {
              if (!isMiniPlayerSeeking && !isNaN(miniPlayerAudio.duration)) {
                  miniPlayerProgress.value = miniPlayerAudio.currentTime;
                  updatePlayerUI();
                  savePlayerState(); // Save state periodically on time update
              }
          };
          handleMiniPlayerEnded = playNextTrack; // Use existing function name
          handleMiniPlayerError = (e) => {
              console.error("Mini Player Audio Error:", e);
              miniPlayerTitle.textContent = "Error loading track";
              // playNextTrack(); // Option: try next on error
          };
          handleMiniPlayerPlay = updatePlayerUI; // Use existing function name
          handleMiniPlayerPause = updatePlayerUI; // Use existing function name

          // Add Event Listeners using named handlers
          miniPlayerAudio.addEventListener('loadedmetadata', handleMiniPlayerLoadedMetadata);
          miniPlayerAudio.addEventListener('timeupdate', handleMiniPlayerTimeUpdate);
          miniPlayerAudio.addEventListener('ended', handleMiniPlayerEnded);
          miniPlayerAudio.addEventListener('error', handleMiniPlayerError);
          miniPlayerAudio.addEventListener('play', handleMiniPlayerPlay); // Update UI on play
          miniPlayerAudio.addEventListener('pause', handleMiniPlayerPause); // Update UI on pause


          // Event Listeners for Controls (these don't need removal in hideMiniPlayer)
          miniPlayerPlayPauseBtn.addEventListener('click', () => {
              if (miniPlayerAudio.paused) {
                  miniPlayerAudio.play().catch(e => console.error("Play error:", e));
              } else {
                  miniPlayerAudio.pause();
              }
              // updatePlayerUI(); // Already handled by 'play'/'pause' events
          });
          miniPlayerNextBtn.addEventListener('click', playNextTrack);
          miniPlayerPrevBtn.addEventListener('click', () => {
              console.log("Previous track functionality: jump to beginning or previous track");
              if (miniPlayerAudio.currentTime > 3 || currentTrackIndex === 0) { // If more than 3s in or first track, restart current
                 miniPlayerAudio.currentTime = 0;
              } else if (currentTrackIndex > 0) { // Go to previous track
                  loadAndPlayTrack(currentTrackIndex - 1);
              }
          });
          miniPlayerCloseBtn.addEventListener('click', hideMiniPlayer);

          // Event Listeners for Progress Bar
          miniPlayerProgress.addEventListener('input', () => {
              isMiniPlayerSeeking = true;
              if (!isNaN(miniPlayerAudio.duration)) {
                 miniPlayerTime.textContent = `${formatTime(miniPlayerProgress.value)} / ${formatTime(miniPlayerAudio.duration)}`;
              }
          });
          miniPlayerProgress.addEventListener('change', () => {
              if (!isNaN(miniPlayerAudio.duration)) {
                  miniPlayerAudio.currentTime = miniPlayerProgress.value;
              }
              isMiniPlayerSeeking = false;
              if (!miniPlayerAudio.paused) {
                 miniPlayerAudio.play().catch(e => console.error("Seek->Play error:", e));
              }
          });

          // <<< Volume Control Listener >>>
          miniPlayerVolume.addEventListener('input', () => {
              miniPlayerAudio.volume = miniPlayerVolume.value;
              savePlayerState(); // Save volume change
          });

          console.log("Mini Player Initialized.");
          // Attempt to load state after initialization
          loadPlayerState();
      }

      function showMiniPlayer() {
          if (miniPlayer) miniPlayer.style.display = 'flex';
      }

      function hideMiniPlayer() {
          if (miniPlayer) miniPlayer.style.display = 'none';
          if (miniPlayerAudio) {
              // <<< Remove event listeners first >>>
              if (handleMiniPlayerLoadedMetadata) miniPlayerAudio.removeEventListener('loadedmetadata', handleMiniPlayerLoadedMetadata);
              if (handleMiniPlayerTimeUpdate) miniPlayerAudio.removeEventListener('timeupdate', handleMiniPlayerTimeUpdate);
              if (handleMiniPlayerEnded) miniPlayerAudio.removeEventListener('ended', handleMiniPlayerEnded);
              if (handleMiniPlayerError) miniPlayerAudio.removeEventListener('error', handleMiniPlayerError);
              if (handleMiniPlayerPlay) miniPlayerAudio.removeEventListener('play', handleMiniPlayerPlay);
              if (handleMiniPlayerPause) miniPlayerAudio.removeEventListener('pause', handleMiniPlayerPause);

              miniPlayerAudio.pause(); // Pause
              miniPlayerAudio.src = ''; // Clear src
              try {
                   miniPlayerAudio.load(); // Explicitly load empty source
               } catch (e) {
                   console.warn("Error calling load() during hideMiniPlayer:", e);
               }
          }
          audioPlaylist = [];
          currentTrackIndex = -1;
          if (miniPlayerTitle) miniPlayerTitle.textContent = "Now Playing...";
          if (miniPlayerProgress) miniPlayerProgress.value = 0;
          if (miniPlayerTime) miniPlayerTime.textContent = "0:00 / 0:00";
          if (miniPlayerPlayPauseBtn) miniPlayerPlayPauseBtn.textContent = '▶️';
          localStorage.removeItem('miniPlayerState'); // Clear saved state on close
          console.log("Mini Player Hidden and State Cleared.");
      }

      function addToPlaylistAndPlay(url, title) {
           if (!miniPlayerAudio) {
               console.error("Audio element not initialized.");
               return;
           }
          const newTrack = { url, title };
          let trackAlreadyExists = false;
          // Check if the exact track already exists anywhere in the playlist
          for(let i = 0; i < audioPlaylist.length; i++) {
              if(audioPlaylist[i].url === url && audioPlaylist[i].title === title) {
                  trackAlreadyExists = true;
                  console.log(`Track "${title}" already in playlist at index ${i}.`);
                  break;
              }
          }

          // Only add if it doesn't exist
          if (!trackAlreadyExists) {
              audioPlaylist.push(newTrack);
              console.log(`Added to playlist: ${title}. New length: ${audioPlaylist.length}`);
          }

          // <<< CHANGE: Play immediately ONLY if nothing is currently assigned/playing >>>
          if (currentTrackIndex === -1 && audioPlaylist.length > 0) {
              // If idle (no track assigned), play the *last added* track
              const targetIndex = audioPlaylist.length - 1;
              console.log(`Player is idle, playing newly added track at index ${targetIndex}: ${audioPlaylist[targetIndex].title}`);
              loadAndPlayTrack(targetIndex);
          } else if (currentTrackIndex >= 0) {
              console.log(`Player has an active track (index ${currentTrackIndex}). Added "${title}" to queue.`);
              // If player is active, just ensure UI reflects potential playlist changes
              // updatePlaylistUI(); // Placeholder for future UI update
          }

          showMiniPlayer(); // Make sure player is visible regardless
      }

       function loadAndPlayTrack(index) {
          if (index < 0 || index >= audioPlaylist.length || !miniPlayerAudio) {
              console.log("Invalid track index or playlist empty.");
              // Don't hide player here automatically, might just be an invalid index attempt
              return;
          }
          currentTrackIndex = index;
          const track = audioPlaylist[currentTrackIndex];
          console.log(`Loading track ${index}: ${track.title}`);

          // Pause current playback before changing src
          miniPlayerAudio.pause();

          miniPlayerAudio.src = track.url;
          miniPlayerTitle.textContent = track.title;
          miniPlayerProgress.value = 0;
          miniPlayerAudio.load();
          miniPlayerAudio.play()
              .then(() => {
                   updatePlayerUI();
                   savePlayerState(); // Save state after starting new track
              })
              .catch(e => {
                   console.error("Error playing track:", e);
                   miniPlayerTitle.textContent = "Error playing";
                   updatePlayerUI();
                   savePlayerState(); // Save state even if error occurred
               });
           showMiniPlayer(); // Ensure player is visible when loading a track
      }

      function playNextTrack() {
           // Play the next index in the current playlist array
           const nextIndex = currentTrackIndex + 1;
           if (nextIndex < audioPlaylist.length) {
              loadAndPlayTrack(nextIndex);
           } else {
              console.log("End of playlist reached.");
              // Optionally loop back to the start?
              // loadAndPlayTrack(0);
              // Or just stop and hide:
              hideMiniPlayer();
           }
      }

      function updatePlayerUI() {
          if (!miniPlayerAudio || !miniPlayerPlayPauseBtn || !miniPlayerTime || !miniPlayerProgress || !miniPlayerTitle) return;

          miniPlayerPlayPauseBtn.textContent = miniPlayerAudio.paused ? '▶️' : '⏸️';

          const currentTime = miniPlayerAudio.currentTime || 0;
          const duration = miniPlayerAudio.duration || 0;
          if (!isNaN(duration) && duration > 0) { // Check duration > 0
              miniPlayerTime.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
              if (miniPlayerProgress.max != duration) {
                   miniPlayerProgress.max = duration;
              }
              // Update progress only if not seeking
              if (!isMiniPlayerSeeking) {
                   miniPlayerProgress.value = currentTime;
              }
          } else {
              miniPlayerTime.textContent = `${formatTime(currentTime)} / --:--`;
              miniPlayerProgress.max = 100; // Default max if duration unknown
               if (!isMiniPlayerSeeking) {
                   miniPlayerProgress.value = 0; // Reset if duration unknown
               }
          }

          // Update Title based on currentTrackIndex
          if (currentTrackIndex !== -1 && currentTrackIndex < audioPlaylist.length) {
               if (!miniPlayerTitle.textContent.startsWith("Error")) { // Avoid overwriting error messages
                  miniPlayerTitle.textContent = audioPlaylist[currentTrackIndex].title;
              }
          } else if (audioPlaylist.length === 0) {
               miniPlayerTitle.textContent = "Now Playing...";
           }
           // Volume is handled by its own event listener + state loading
      }
      // --- Mini Audio Player Logic --- END

      // --- Utility Functions ---
      function formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + ['Bytes', 'KB', 'MB', 'GB', 'TB'][i]; }
      function pruneHistory(historyArray) { const max = MAX_HISTORY_LENGTH * 2; return historyArray.length > max ? historyArray.slice(historyArray.length - max) : historyArray; }

      // --- Tree Navigation Function ---
      function toggleChildren(el) { const li = el.parentElement; let ul = li.querySelector('ul'); if (!ul) return; if (ul.innerHTML.trim() === "") { const path = li.querySelector('.folder-link')?.getAttribute('data-path'); if(!path) return; fetch(`/folder_children?drive={{ drive }}&api_key={{ api_key|urlencode }}&path=${encodeURIComponent(path)}`).then(r => r.text()).then(h => { ul.innerHTML = h; ul.style.display = 'block'; li.classList.add('expanded'); el.textContent = '🔽'; }).catch(e => console.error('FC fetch err:', e)); } else { const d = ul.style.display; ul.style.display = (d === 'none' || d === '') ? 'block' : 'none'; li.classList.toggle('expanded', ul.style.display === 'block'); el.textContent = (ul.style.display === 'block') ? '🔽' : '▶️'; } }

      // --- File List Loading Function ---
      function loadFileList(path) {
          const drive = "{{ drive }}";
          const api_key = "{{ api_key|urlencode }}";
          const params = new URLSearchParams(window.location.search);
          const sort = params.get('sort') || 'name';
          const dir = params.get('dir') || 'asc';
          fetch(`/filelist?drive=${encodeURIComponent(drive)}&api_key=${encodeURIComponent(api_key)}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}`)
              .then(r => { if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`); return r.text(); })
              .then(h => {
                  if (!fileListContainer) { console.error("File list container not found during loadFileList."); return; }
                  fileListContainer.innerHTML = h;
                  const loc = document.querySelector('.location-bar h3');
                  if(loc) loc.textContent = `📂 (${drive.slice(0,-2)}): ${path || '/'}`;
                  const btns = document.querySelectorAll('.sort-buttons a');
                  const n=(s,d)=>(s==='name'?(d==='asc'?'desc':'asc'):'asc');
                  const dt=(s,d)=>(s==='date'?(d==='asc'?'desc':'asc'):'asc');
                  const sz=(s,d)=>(s==='size'?(d==='asc'?'desc':'asc'):'asc');
                  if(btns.length===3){
                      btns[0].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=name&dir=${n(sort,dir)}&api_key=${api_key}`;
                      btns[1].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=date&dir=${dt(sort,dir)}&api_key=${api_key}`;
                      btns[2].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=size&dir=${sz(sort,dir)}&api_key=${api_key}`;
                  }
                  const currentPath = new URLSearchParams(window.location.search).get('path') || '';
                   const decodedCurrentPath = decodeURIComponent(currentPath);
                   // Only push state if the path is actually different to avoid loop on popstate
                   if (decodedCurrentPath !== path) {
                      history.pushState({path:path}, '', `/?drive=${drive}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}&api_key=${api_key}`);
                   }
              })
              .catch(e => console.error('FL load failed:', e));
       }

      // --- Browser History Functions ---
      function goBack() { history.back(); }
      function goForward() { history.forward(); }
      window.addEventListener('popstate', (e) => {
          const p = e.state?.path ?? (new URLSearchParams(location.search).get('path') || '');
          loadFileList(p); // Reload file list based on history state
      });

      // --- Drag & Drop Upload Functions ---
      function preventDefaults(e){e.preventDefault();e.stopPropagation();}
      function handleDrop(e){ const dt=e.dataTransfer; const files=dt.files; if(files.length) handleFiles(files); }
      function handleFiles(files){ [...files].forEach(uploadFile); }
      function uploadFile(file){
          const url = `/upload?drive={{ drive }}&api_key={{ api_key|urlencode }}&path={{ current_path }}`; // Ensure current_path is available
          const fd=new FormData(); fd.append('file',file);
          const xhr=new XMLHttpRequest(); xhr.open('POST',url,true);
          const pCont=document.getElementById('upload-progress');
          const pItem=document.createElement('div'); pItem.className='progress-item';
          pItem.innerHTML=`<div>${file.name} (${formatFileSize(file.size)})</div><div class="progress-bar"></div>`;
          if(pCont) pCont.appendChild(pItem);
          const pBar=pItem.querySelector('.progress-bar');
          xhr.upload.onprogress=ev=>{if(ev.lengthComputable&&pBar)pBar.style.width=((ev.loaded/ev.total)*100)+'%'};
          xhr.onload=()=>{
              if(xhr.status>=200&&xhr.status<300){
                  if(pBar) pBar.style.width='100%'; pItem.style.backgroundColor='#10b981';
                  setTimeout(()=>{pItem.remove(); if(pCont&&pCont.children.length===0) loadFileList("{{ current_path }}");}, 1000); // Reload on success
        } else {
                  pItem.style.backgroundColor='#ef4444'; pItem.innerHTML+=`<div style="color:var(--danger);margin-top:8px;">Fail: ${xhr.statusText||'Err'}</div>`;
                  setTimeout(()=>pItem.remove(), 3000);
              }
          };
          xhr.onerror=()=>{
              pItem.style.backgroundColor='#ef4444'; pItem.innerHTML+=`<div style="color:var(--danger);margin-top:8px;">Net Err.</div>`;
              setTimeout(()=>pItem.remove(), 3000);
          };
          xhr.send(fd);
      }

      // --- Main Chat Event Listeners Setup Function ---
       function setupMainChatListeners() {
          if(mainSendButton) mainSendButton.addEventListener('click', () => sendMessage());
          if(mainChatInput) mainChatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { sendMessage(); e.preventDefault(); } });
          if(mainImageUploadButton) mainImageUploadButton.addEventListener('click', () => { if (mainMicButton?.classList.contains('recording')) return; mainImageUploadInput?.click(); });
          if(mainImageUploadInput) mainImageUploadInput.addEventListener('change', handleMainImageFileSelect);
          if(mainRemoveImageButton) mainRemoveImageButton.addEventListener('click', clearMainAttachedImage);
          if(mainRefreshChatButton) mainRefreshChatButton.addEventListener('click', clearMainChat);
          if (mainMicButton) mainMicButton.addEventListener('click', toggleMainRecording);
      }

      // --- Chat Functionality (Common & Main) ---
      function addMessageToChat(message, sender, chatElements, imageUrl = null, historyArray = null) { if (!chatElements?.messages) { console.error("addMsg: No messages element"); return; } const el = document.createElement('div'); el.classList.add('message', sender==='user'?'user-message':'assistant-message'); if (sender==='assistant') { marked.setOptions({breaks:true}); el.innerHTML=DOMPurify.sanitize(marked.parse(message)); } else { el.textContent=message; } if (sender==='user' && imageUrl) { const img=document.createElement('img'); img.src=imageUrl; img.alt="Attached"; img.classList.add('attached-image-thumb'); el.appendChild(img); } chatElements.messages.appendChild(el); requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); if(historyArray){ const entry={role:(sender==='user'?'user':'model'),parts:[]}; if(message) entry.parts.push({text:message}); if(entry.parts.length>0){ historyArray.push(entry); const pruned=pruneHistory(historyArray); if(pruned!==historyArray){ historyArray.length=0; historyArray.push(...pruned); }}} }
      function updateLastAssistantMessage(textChunk, chatElements) { if (!chatElements?.messages) return; let last=chatElements.messages.querySelector('.assistant-message:last-child'); if(!last || last.dataset.streaming !== 'true'){ last=document.createElement('div'); last.className='message assistant-message'; last.dataset.streaming='true'; chatElements.messages.appendChild(last); } last.textContent += textChunk; requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); }
      function finalizeLastAssistantMessage(chatElements, historyArray) { if (!chatElements?.messages) return; let last=chatElements.messages.querySelector('.assistant-message:last-child[data-streaming="true"]'); if(last){ delete last.dataset.streaming; const txt=last.textContent; marked.setOptions({breaks:true}); last.innerHTML=DOMPurify.sanitize(marked.parse(txt)); if(historyArray&&txt){ const lastH=historyArray[historyArray.length-1]; if(!lastH || !(lastH.role==='model'&&lastH.parts[0]?.text===txt)){ historyArray.push({role:'model',parts:[{text:txt}]}); const pruned=pruneHistory(historyArray); if(pruned!==historyArray){ historyArray.length=0; historyArray.push(...pruned); }}} requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); } }

      async function sendMessage(instanceId = null) {
          let chatInstance, chatElements = {}, historyArray, currentImgRef, relPath = null;
          let isFileChat = instanceId !== null && fileChatInstances[instanceId];
          let instanceType = isFileChat ? fileChatInstances[instanceId].type : null; // 'media' or 'document' or null

          // --- Determine context (Main Chat vs File Chat) ---
          if (isFileChat) {
              chatInstance = fileChatInstances[instanceId];
              chatElements = chatInstance.elements;
              historyArray = chatInstance.history;
              relPath = chatInstance.relPath;
              // currentImgRef = chatInstance; // We don't use the temporary attached image for file chat
          } else {
              // Main chat context
              chatElements = {
                  input: mainChatInput, sendButton: mainSendButton, modelSelect: mainModelSelect, messages: mainChatMessages,
                  imagePreviewArea: mainImagePreviewArea, imagePreview: mainImagePreview, imageFilename: mainImageFilename,
                  removeImageButton: mainRemoveImageButton, imageUploadButton: mainImageUploadButton, imageUploadInput: mainImageUploadInput,
                  micButton: mainMicButton, micStatus: mainMicStatus
              };
              historyArray = mainChatHistory;
              currentImgRef = { get attachedImageData() { return mainAttachedImageData; }, set attachedImageData(v) { mainAttachedImageData = v; } };
          }

          // --- Validate required elements ---
          if (!chatElements.input || !chatElements.modelSelect || !chatElements.sendButton || !chatElements.messages) {
              console.error("sendMessage Error: Missing critical chat elements for", instanceId || "main chat", chatElements);
              if(chatElements.sendButton) chatElements.sendButton.disabled = false;
              if(chatElements.micButton) chatElements.micButton.disabled = false; // Check existence
              return;
          }

          const msg = chatElements.input.value.trim();
          const model = chatElements.modelSelect.value;

          // --- Check if message is empty (allow sending if image is attached in MAIN chat) ---
          let mainChatImageAttached = !isFileChat && currentImgRef?.attachedImageData;
          if (!msg && !mainChatImageAttached && !isFileChat) {
              // Only return if message is empty AND it's the main chat without an image attached
              // File chat always proceeds to send the inherent image
              console.log("Empty message in main chat, returning.");
              return;
          }

          // --- Display User Message ---
          // For main chat, display attached image preview if present
          const userDisplayImageUrl = mainChatImageAttached ? chatElements.imagePreview.src : null;
          addMessageToChat(msg || ' ', 'user', chatElements, userDisplayImageUrl, historyArray);

          // --- Prepare Payload ---
          let payload;
          let fetchOpts = { method: 'POST' };

          // --- Disable buttons and clear input --- START
          chatElements.sendButton.disabled = true;
          if(chatElements.micButton) chatElements.micButton.disabled = true;
          if(chatElements.input) chatElements.input.value = ''; // Clear input after getting value

          if (mainChatImageAttached) {
              clearMainAttachedImage(); // Clear main preview
          } else if (isFileChat && chatElements.imagePreviewArea && instanceType === 'media') {
              // Only clear attached image preview for media file chats if one was temporarily attached (unlikely current flow)
              clearAttachedImage(instanceId);
          }
          // --- Disable buttons and clear input --- END

          try {
              addMessageToChat("...".padStart(3), 'assistant', chatElements, null, null); // Thinking indicator (don't add to history)
              const thinking = chatElements.messages.lastElementChild;

              if (isFileChat && instanceType === 'media' && relPath) {
                  // FILE CHAT (MEDIA): Always send image + message + history via FormData
                  console.log(`File chat (Media - ${instanceId}): Fetching image blob for ${relPath}`);
                  // Fetch the image Blob asynchronously
                  const drive = "{{ drive|urlencode }}";
                  const apiKey = "{{ api_key|urlencode }}";
                  const imageUrl = `/download?drive=${drive}&path=${encodeURIComponent(relPath)}&api_key=${apiKey}`;
                  const imageResponse = await fetch(imageUrl);
                  if (!imageResponse.ok) throw new Error(`Failed to fetch image for chat: ${imageResponse.statusText}`);
                  const imageBlob = await imageResponse.blob();

                  payload = new FormData();
                  payload.append('message', msg || '');
                  payload.append('model', model);
                  payload.append('history', JSON.stringify(historyArray.slice(0, -1))); // Send history *before* the current user msg
                  payload.append('image', imageBlob, fileChatInstances[instanceId].fileName); // Add the fetched image blob

                  fetchOpts.body = payload; // Set FormData as body
                  // Browser sets Content-Type automatically for FormData

              } else if (isFileChat && instanceType === 'document') {
                  // FILE CHAT (DOCUMENT): Send message + history + instanceId via JSON
                  console.log(`File chat (Document - ${instanceId}): Sending JSON payload.`);
                  payload = JSON.stringify({
                      message: msg || '',
                      model: model,
                      history: historyArray.slice(0, -1), // Send history *before* current user msg
                      instanceId: instanceId // <<< Include instanceId for RAG lookup
                  });
                  fetchOpts.body = payload;
                  fetchOpts.headers = { 'Content-Type': 'application/json' };

              } else if (isFileChat && instanceType === 'video') {
                  // <<< FILE CHAT (VIDEO): Send JSON payload, potentially flag for first message >>>
                  console.log(`File chat (Video - ${instanceId}): Sending JSON payload.`);
                  const isFirstVideoMessage = historyArray.length <= 1; // Check history length AFTER adding user message

                  payload = JSON.stringify({
                      message: msg || '', // Send user message
                      model: model,
                      history: historyArray.slice(0, -1), // Send history *before* current user msg
                      instanceId: instanceId,
                      processFirstVideoPart: isFirstVideoMessage // <<< Flag for backend
                  });
                  fetchOpts.body = payload;
                  fetchOpts.headers = { 'Content-Type': 'application/json' };
                  if (isFirstVideoMessage) {
                      console.log("Flagging this as the first video message for backend processing.");
                  }
              } else {
                  // MAIN CHAT: Send JSON or FormData based on attached image
                  const mainImageData = currentImgRef?.attachedImageData;
                  if (mainImageData) {
                      payload = new FormData();
                      payload.append('message', msg || '');
                      payload.append('model', model);
                      payload.append('history', JSON.stringify(historyArray.slice(0, -1)));
                      payload.append('image', mainImageData);
                      fetchOpts.body = payload;
                      // Browser sets Content-Type automatically
                  } else {
                      payload = JSON.stringify({ message: msg, model: model, history: historyArray.slice(0, -1) });
                      fetchOpts.body = payload;
                      fetchOpts.headers = { 'Content-Type': 'application/json' };
                  }
                  currentImgRef.attachedImageData = null; // Clear main attached image data after preparing payload
              }

              // --- Make API Call ---
              console.log(`Sending chat request. IsFileChat: ${isFileChat}`, fetchOpts);
              const res = await fetch('/chat', fetchOpts);

              // --- Process Response ---
              if (thinking && chatElements.messages.contains(thinking)) chatElements.messages.removeChild(thinking);

              if (res.ok && res.headers.get('Content-Type')?.includes('text/event-stream')) {
                  const r = res.body.getReader();
                  const dec = new TextDecoder();
                  let buf = '', evTxt = '';
                  while (true) {
                      const { value, done } = await r.read();
                      if (done) { finalizeLastAssistantMessage(chatElements, historyArray); break; }
                      buf += dec.decode(value, { stream: true });
                      let b = buf.indexOf('\n\n');
                      while (b !== -1) {
                          evTxt = buf.substring(0, b); buf = buf.substring(b + 2);
                          if (evTxt.startsWith('event: end')) { finalizeLastAssistantMessage(chatElements, historyArray); break; }
                          if (evTxt.startsWith('data: ')) {
                              const j = evTxt.substring(6); try { const d = JSON.parse(j);
                                  if (d.response) updateLastAssistantMessage(d.response, chatElements);
                                  else if (d.error) { updateLastAssistantMessage(`\n[ERR: ${d.error}]`, chatElements); finalizeLastAssistantMessage(chatElements, historyArray); }
                              } catch (e) { console.error("SSE err:", e, "Data:", j); }
                          }
                          b = buf.indexOf('\n\n');
                      } if (evTxt && evTxt.startsWith('event: end')) break;
                  }
              } else {
                  // Handle non-streaming error
                  let eMsg = `Err: ${res.statusText}`;
                  try { const ed = await res.json(); eMsg = `Err: ${ed.error || res.statusText}`; } catch (e) { }
                  addMessageToChat(eMsg, 'assistant', chatElements, null, historyArray);
              }
          } catch (err) {
              // --- Handle Fetch/Processing Errors ---
              const t = chatElements.messages?.querySelector('.assistant-message:last-child');
              if (t && t.textContent === '...' && chatElements.messages.contains(t)) chatElements.messages.removeChild(t);
              console.error('Chat Err:', err);
              addMessageToChat(`Error occurred: ${err.message}`, 'assistant', chatElements, null, historyArray);
          } finally {
              // --- Re-enable buttons ---
              if(chatElements.sendButton) chatElements.sendButton.disabled = false;
              if(chatElements.micButton) chatElements.micButton.disabled = false; // Check existence
              // Clear main attached image explicitly (redundant but safe)
              if (!isFileChat && currentImgRef) currentImgRef.attachedImageData = null;
          }
      }

      // Image Handling (Main & File Specific)
      function handleMainImageFileSelect(e){const f=e.target.files[0];if(f&&f.type.startsWith('image/')){mainAttachedImageData=f;const r=new FileReader();r.onload=ev=>{if(mainImagePreview)mainImagePreview.src=ev.target.result;if(mainImageFilename)mainImageFilename.textContent=f.name;if(mainImagePreviewArea)mainImagePreviewArea.style.display='flex';};r.readAsDataURL(f);}else{clearMainAttachedImage();if(f)alert('Images only.');}if(mainImageUploadInput)mainImageUploadInput.value=null;}
      function clearMainAttachedImage(){mainAttachedImageData=null;if(mainImagePreview)mainImagePreview.src='#';if(mainImageFilename)mainImageFilename.textContent='';if(mainImagePreviewArea)mainImagePreviewArea.style.display='none';if(mainImageUploadInput)mainImageUploadInput.value=null;}
      function handleFileImageSelect(e,id){const i=fileChatInstances[id];if(!i?.elements.imagePreviewArea||!i?.elements.imagePreview)return;const f=e.target.files[0];if(f&&f.type.startsWith('image/')){i.attachedImageData=f;const r=new FileReader();r.onload=ev=>{i.elements.imagePreview.src=ev.target.result;if(i.elements.imageFilename)i.elements.imageFilename.textContent=f.name;i.elements.imagePreviewArea.style.display='flex';};r.readAsDataURL(f);}else{clearAttachedImage(id);if(f)alert('Images only.');}if(e.target)e.target.value=null;}
      function clearAttachedImage(id){const i=fileChatInstances[id];if(i){i.attachedImageData=null;if(i.elements.imagePreview)i.elements.imagePreview.src='#';if(i.elements.imageFilename)i.elements.imageFilename.textContent='';if(i.elements.imagePreviewArea)i.elements.imagePreviewArea.style.display='none';if(i.elements.imageUploadInput)i.elements.imageUploadInput.value=null;}}
      // Audio Handling (Main Chat Only For Now)
      async function toggleMainRecording(){if(!mainMicButton)return;if(isMainRecording){mainMediaRecorder?.stop();isMainRecording=false;mainMicButton.classList.remove('recording');mainMicButton.disabled=true;if(mainMicStatus)mainMicStatus.textContent='Processing...';}else{try{const s=await navigator.mediaDevices.getUserMedia({audio:true});mainMediaRecorder=new MediaRecorder(s);mainAudioChunks=[];mainMediaRecorder.ondataavailable=e=>mainAudioChunks.push(e.data);mainMediaRecorder.onstop=async()=>{const b=new Blob(mainAudioChunks,{type:'audio/ogg; codecs=opus'});mainAudioChunks=[];s.getTracks().forEach(t=>t.stop());await sendAudioData(b);mainMicButton.disabled=false;if(mainMicStatus)mainMicStatus.textContent='';};mainMediaRecorder.start();isMainRecording=true;mainMicButton.classList.add('recording');if(mainMicStatus)mainMicStatus.textContent='Recording...';if(mainChatInput)mainChatInput.disabled=true;if(mainSendButton)mainSendButton.disabled=true;if(mainImageUploadButton)mainImageUploadButton.disabled=true;}catch(err){console.error("Mic err:",err);if(mainMicStatus)mainMicStatus.textContent='Mic Error';alert(`Mic fail: ${err.message}`);isMainRecording=false;mainMicButton?.classList.remove('recording');if(mainChatInput)mainChatInput.disabled=false;if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainMicButton)mainMicButton.disabled=false;}}}
      async function sendAudioData(blob){if(!mainModelSelect)return;const m=mainModelSelect.value;const fd=new FormData();fd.append('audio',blob,'rec.ogg');fd.append('model',m);const els={messages:mainChatMessages};addMessageToChat("(Audio sent)",'user',els,null,mainChatHistory);try{addMessageToChat("...",'assistant',els,null,mainChatHistory);const t=els.messages.lastElementChild;const r=await fetch('/chat_audio',{method:'POST',body:fd});if(t&&els.messages.contains(t))els.messages.removeChild(t);if(!r.ok){let msg=`Aud Err: ${r.statusText}`;try{const d=await r.json();msg=`Aud Err: ${d.error||r.statusText}`; }catch(e){}addMessageToChat(msg,'assistant',els,null,mainChatHistory);}else{const d=await r.json();addMessageToChat(d.response,'assistant',els,null,mainChatHistory);}}catch(err){const t=els.messages?.querySelector('.assistant-message:last-child');if(t&&t.textContent==='...'&&els.messages.contains(t))els.messages.removeChild(t);console.error('Aud Chat Err:',err);addMessageToChat('Audio proc err.','assistant',els,null,mainChatHistory);}finally{if(mainChatInput)mainChatInput.disabled=false;if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainMicButton)mainMicButton.disabled=false;if(mainMicStatus)mainMicStatus.textContent='';}}
      // Main Chat Refresh
      function clearMainChat(){console.log("Clearing main chat...");if(mainChatMessages)mainChatMessages.innerHTML='';mainChatHistory=[];clearMainAttachedImage();if(mainChatInput)mainChatInput.value='';const els={messages:mainChatMessages};if(mainChatMessages)addMessageToChat("안녕하세요!",'assistant',els);if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainChatInput)mainChatInput.disabled=false;if(mainMicButton){mainMicButton.disabled=false;if(isMainRecording){mainMediaRecorder?.stop();isMainRecording=false;mainMicButton.classList.remove('recording');}}if(mainMicStatus)mainMicStatus.textContent='';}

      // --- New Preview+Chat Instance Logic --- START
      function createPreviewChatInstance(instanceId, fileName, relPath, type) {
          console.log(`Creating instance ${instanceId} for ${fileName} (type: ${type})`); // Log type

          // <<< NEW: Close mini player if opening a video preview >>>
          if (type === 'video') {
              console.log("Video instance detected, attempting to hide mini player.");
              hideMiniPlayer();
          }

          const instanceDiv = document.createElement('div'); instanceDiv.id = instanceId; instanceDiv.className = 'preview-chat-instance';
          const header = document.createElement('div'); header.className = 'preview-chat-header';
          const title = document.createElement('span'); title.className = 'preview-chat-filename'; title.textContent = fileName; title.title = relPath;
          const closeBtn = document.createElement('button'); closeBtn.className = 'preview-chat-close-btn'; closeBtn.innerHTML = '&times;'; closeBtn.title = 'Close'; closeBtn.onclick = () => closePreviewChatInstance(instanceId);
          header.appendChild(title); header.appendChild(closeBtn);
          const contentDiv = document.createElement('div'); contentDiv.className = 'preview-chat-content';
          const previewArea = document.createElement('div'); previewArea.className = 'preview-area';
          const chatArea = document.createElement('div'); chatArea.className = 'chat-area'; chatArea.style.cssText='display:flex;flex-direction:column;height:100%;overflow:hidden;';

          const clonedElements = {
              previewArea: previewArea,
              modelSelect:null, messages:null, imagePreviewArea:null, imagePreview:null, imageFilename:null, removeImageButton:null, micStatus:null, inputArea:null, imageUploadButton:null, imageUploadInput:null, micButton:null, input:null, sendButton:null
          };

          const cloneConfig = [
              { mainParentSelector:'.model-selector', elementSelector:'select', cloneId:'modelSelect' },
              { createNew:'div', cloneId:'messages', newClass:'chat-messages', initialContent:true },
              { mainId:'image-preview-area', cloneId:'imagePreviewArea', elementType:'div', handleSubElements:true },
              { mainId:'mic-status', cloneId:'micStatus', elementType:'span', newClass:'mic-status' },
              { mainId:'chat-input-area', cloneId:'inputArea', elementType:'div', handleSubElements:true }
          ];

          cloneConfig.forEach(cfg => { 
              let cloned = null; 
              let mainE = cfg.mainId ? document.getElementById(cfg.mainId) : null; 
              let mainP = cfg.mainParentSelector ? mainChatContainer?.querySelector(cfg.mainParentSelector) : null; 
              
              if(cfg.createNew){ 
                  cloned = document.createElement(cfg.createNew); 
                  cloned.id = `${instanceId}-${cfg.cloneId}`; 
                  if(cfg.newClass) cloned.className = cfg.newClass; 
                  clonedElements[cfg.cloneId] = cloned; 
                  if(cfg.initialContent && cfg.cloneId === 'messages')
                      addMessageToChat("파일 질문:", 'assistant', {messages: cloned}); 
              } else if(mainP){ 
                  cloned = mainP.cloneNode(true); 
                  const elIn = cloned.querySelector(cfg.elementSelector); 
                  if(elIn){ 
                      elIn.id = `${instanceId}-${cfg.mainId || cfg.cloneId}`; 
                      clonedElements[cfg.cloneId] = elIn; 
                  } else console.warn(`Elem ${cfg.elementSelector} not in ${cfg.mainParentSelector}`); 
              } else if(mainE){ 
                  cloned = mainE.cloneNode(true); 
                  cloned.id = `${instanceId}-${cfg.mainId}`; 
                  clonedElements[cfg.cloneId] = cloned; 
                  if(cfg.newClass) cloned.className = cfg.newClass; 
                  if(cfg.handleSubElements){ 
                      if(cfg.cloneId === 'imagePreviewArea'){ 
                          cloned.style.display = 'none'; 
                          const img = cloned.querySelector('#image-preview'); 
                          if(img){
                              img.id = `${instanceId}-image-preview`;
                              clonedElements.imagePreview = img;
                          } 
                          const span = cloned.querySelector('#image-filename'); 
                          if(span){
                              span.id = `${instanceId}-image-filename`;
                              clonedElements.imageFilename = span;
                          } 
                          const btn = cloned.querySelector('#remove-image-button'); 
                          if(btn){
                              btn.id = `${instanceId}-remove-image-button`;
                              btn.onclick = () => clearAttachedImage(instanceId);
                              clonedElements.removeImageButton = btn;
                          } 
                      } else if(cfg.cloneId === 'inputArea'){ 
                          const fileInput = document.createElement('input'); 
                          fileInput.type = 'file';
                          fileInput.id = `${instanceId}-image-upload`;
                          fileInput.accept = 'image/*';
                          fileInput.style.display = 'none'; 
                          fileInput.onchange = (e) => handleFileImageSelect(e, instanceId); 
                          clonedElements.imageUploadInput = fileInput; 
                          cloned.insertBefore(fileInput, cloned.firstChild); 
                          
                          const imgBtn = cloned.querySelector('#image-upload-button'); 
                          if(imgBtn){
                              imgBtn.id = `${instanceId}-image-upload-button`;
                              imgBtn.onclick = () => fileInput.click();
                              clonedElements.imageUploadButton = imgBtn;
                          } 
                          
                          const micBtn = cloned.querySelector('#mic-button'); 
                          if(micBtn){
                              micBtn.id = `${instanceId}-mic-button`;
                              micBtn.disabled = true;
                              micBtn.title = "Audio(File Disabled)";
                              clonedElements.micButton = micBtn;
                          } 
                          
                          const inputEl = cloned.querySelector('#chat-input'); 
                          if(inputEl){
                              inputEl.id = `${instanceId}-chat-input`;
                              inputEl.onkeypress = (e) => {
                                  if(e.key === 'Enter' && !e.shiftKey){
                                      sendMessage(instanceId);
                                      e.preventDefault();
                                  }
                              };
                              clonedElements.input = inputEl;
                          } 
                          
                          const sendBtn = cloned.querySelector('#send-button'); 
                          if(sendBtn){
                              sendBtn.id = `${instanceId}-send-button`;
                              sendBtn.onclick = () => sendMessage(instanceId);
                              clonedElements.sendButton = sendBtn;
                          } 
                      } 
                  } 
              } else console.warn("Clone failed:", cfg); 
              
              if(cloned) chatArea.appendChild(cloned); 
          });
          
          contentDiv.appendChild(previewArea);
          contentDiv.appendChild(chatArea);

          instanceDiv.appendChild(header);
          instanceDiv.appendChild(contentDiv);
          document.body.appendChild(instanceDiv);

          // <<< Find messages div AFTER appending to body >>>
          const messagesDiv = document.getElementById(`${instanceId}-messages`);
          if (!messagesDiv) {
               console.error(`CRITICAL: Could not find messages div #${instanceId}-messages after creation!`);
          }
          clonedElements.messages = messagesDiv; // Ensure messages reference is correct

          fileChatInstances[instanceId] = { fileName: fileName, relPath: relPath, elements: clonedElements, history: [], attachedImageData: null, type: type };
          // Re-add initial message using the found messagesDiv
          if (clonedElements.messages) {
              addMessageToChat("파일 질문:", 'assistant', { messages: clonedElements.messages });
              const initMsg = clonedElements.messages.lastElementChild?.textContent;
              if(initMsg) fileChatInstances[instanceId].history.push({ role: 'assistant', parts: [{ text: initMsg }] });
          }

          console.log(`Created instance: ${instanceId}`, fileChatInstances[instanceId]);
          loadPreviewContent(instanceId, relPath, fileName);

          // Return the cloned elements for direct use
          return clonedElements;
      }

      function closePreviewChatInstance(instanceId) {
          const instanceData = fileChatInstances[instanceId];

          if (instanceData) {
              const chatElements = instanceData.elements;
              const instanceType = instanceData.type;

              // Clear media elements if they exist
              const pA = chatElements?.previewArea;
              if(pA){const v=pA.querySelector('video,audio');if(v){v.pause();v.src='';}const i=pA.querySelector('iframe');if(i)i.src='about:blank';}

              // Remove the instance Div from the DOM
              const iD=document.getElementById(instanceId); if(iD)iD.remove(); else console.warn(`Instance div ${instanceId} not found`);

              // <<< If it was a document OR video instance, clear the backend cache >>>
              // Using the unified endpoint
              if (instanceType === 'document' || instanceType === 'video') {
                  console.log(`Clearing backend cache for ${instanceType} instance: ${instanceId}`);
                  const apiKey = "{{ api_key|urlencode }}";
                  fetch('/clear_instance_cache', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'X-Api-Key': apiKey // Send API key in header
                      },
                      body: JSON.stringify({ instanceId: instanceId })
                  })
                  .then(response => {
                      if (!response.ok) {
                          console.error(`Failed to clear cache for ${instanceId}. Status: ${response.status}`);
                          response.json().then(err => console.error("Cache clear error:", err.error)).catch(() => {});
                      } else {
                          console.log(`Backend cache cleared successfully for ${instanceId}`);
                      }
                  })
                  .catch(error => {
                      console.error(`Error calling /clear_instance_cache for ${instanceId}:`, error);
                  });
              }

              // Delete the instance data from the frontend store
              delete fileChatInstances[instanceId]; console.log(`Closed instance: ${instanceId}`);
          } else {
              console.warn(`Attempted to close non-existent instance: ${instanceId}`);
          }
      }

      function loadPreviewContent(instanceId, relPath, fileName) {
          const instance = fileChatInstances[instanceId];
          if (!instance || !instance.elements?.previewArea) {
              console.error(`Preview load ERROR: Instance ${instanceId} or previewArea element missing in instance data.`);
              const paDiv = document.getElementById(instanceId)?.querySelector('.preview-area');
              if(paDiv) paDiv.innerHTML = '<span class="preview-placeholder">Error loading preview (Instance Data Missing).</span>';
              return;
          }
          const previewArea = instance.elements.previewArea;
          previewArea.innerHTML='<span class="preview-placeholder">Loading...</span>';

          const drv="{{ drive|urlencode }}"; const key="{{ api_key|urlencode }}";
          const ext=fileName.includes('.')?fileName.split('.').pop().toLowerCase():'';
          const vE=['mp4','webm','ogg','mov','avi','mkv','wmv','mpg','flv','3gpp'], aE=['mp3','wav','ogg','aac','flac'], iE=['jpg','jpeg','png','gif','bmp','webp','svg','ico'], tE=['py','js','html','css','java','c','cpp','cs','php','rb','go','rs','swift','kt','md','txt','json','xml','yaml','yml','ini','cfg','log','sh','bat','ps1','csv'], pE=['pdf'];
          let pUrl=null, pType=null;
          const encP=encodeURIComponent(relPath);

          if(vE.includes(ext)){pType='video';pUrl=`/stream/${encP}?drive=${drv}&api_key=${key}`;}else if(aE.includes(ext)){pType='audio';pUrl=`/stream/${encP}?drive=${drv}&api_key=${key}`;}else if(iE.includes(ext)){pType='image';pUrl=`/preview_image/${encP}?drive=${drv}&api_key=${key}`;}else if(tE.includes(ext)){pType='text';pUrl=`/preview_text/${encP}?drive=${drv}&api_key=${key}`;}else if(pE.includes(ext)){pType='pdf';pUrl=`/preview_pdf/${encP}?drive=${drv}&api_key=${key}`;} else { pType = 'unsupported'; }

          let el;
          if (pType !== 'unsupported') {
              console.log(`Loading ${pType} preview for ${relPath} (${fileName}) in ${instanceId}`);
              if (pType==='video' && pUrl){ el=document.createElement('video');el.controls=true;el.autoplay=true;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Video failed.</span>';}; }
              else if (pType==='audio' && pUrl){ el=document.createElement('audio');el.controls=true;el.autoplay=true;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Audio failed.</span>';}; }
              else if (pType==='image' && pUrl){ el=document.createElement('img');el.alt=fileName;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Image failed.</span>';}; }
              else if ((pType==='text' || pType==='pdf') && pUrl){ el=document.createElement('iframe');el.style.cssText='width:100%;height:100%;border:none;';el.src=pUrl;el.onload=()=>console.log(`Iframe ${pType} loaded.`);el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Preview failed.</span>';}; }

              if(el){ previewArea.innerHTML=''; previewArea.appendChild(el); }
              else { previewArea.innerHTML='<span class="preview-placeholder">Preview generation failed.</span>'; console.warn(`Preview element generation failed for type ${pType}, URL: ${pUrl}`); }
               } else {
              previewArea.innerHTML='<span class="preview-placeholder">Preview not supported for this file type.</span>';
              console.log(`Preview not supported for extension: ${ext}`);
          }
      }
      function closeAllPreviewChatInstances() { Object.keys(fileChatInstances).forEach(id => closePreviewChatInstance(id)); }
      // --- New Preview+Chat Instance Logic --- END

      // --- Initialize after DOM is ready ---
      document.addEventListener('DOMContentLoaded', function() {
          // --- Define Event Handlers within DOMContentLoaded ---
          // (These need to be defined before they are attached below)
          function handleTreeClick(e) {
              let target = e.target;
              if (target.tagName.toLowerCase() === 'a' && target.classList.contains('folder-link')) {
                  e.preventDefault();
                  let li = target.parentElement;
                  let arrow = li.querySelector('.toggle-arrow');
                  if (arrow) toggleChildren(arrow); // Calls global toggleChildren
                  loadFileList(target.getAttribute('data-path')); // Calls global loadFileList
              }
          }

          function handleFileListSingleClick(e) {
              let targetLink = e.target.closest('a');
              let fileEntry = e.target.closest('.file-entry');
              // Navigate into folder on single click
              if (targetLink && fileEntry && fileEntry.dataset.isDir === 'true') {
                   if (e.detail === 1) { // Ensure it's a single click
                       e.preventDefault();
                       const path = targetLink.getAttribute('href')?.split('path=')[1]?.split('&')[0];
                       if (path !== undefined) {
                           loadFileList(decodeURIComponent(path)); // Calls global loadFileList
                       } else {
                           console.warn("Could not extract path from folder link:", targetLink.getAttribute('href'));
                       }
                   }
               }
          }

          function handleFileListDoubleClick(e) {
              const fileEntry = e.target.closest('.file-entry');
              if (!fileEntry || fileEntry.dataset.isDir === 'true') return; // Ignore double clicks on folders
              const relPath = fileEntry.dataset.relPath; if (!relPath) { console.warn("DBLClick: Missing relPath"); return; }
              const fileName = fileEntry.querySelector('.file-name')?.textContent || relPath.split('/').pop();
              const fileExt = fileName.includes('.') ? fileName.split('.').pop().toLowerCase() : '';

              console.log(`[DBLClick] Detected for file: ${fileName}, Ext: ${fileExt}, Path: ${relPath}`); // <<< DEBUG LOG

              // Define File Type Categories
              const llmImageExts=['png','jpg','jpeg','webp','heic','heif'];
              const llmDocExts=['pdf','txt','md','py','js','html','css','json', 'csv', 'xml', 'yaml', 'yml', 'ini', 'cfg', 'log', 'sh', 'bat', 'ps1']; // <<< EXPANDED RAG types
              const llmVideoExts=['mp4','mpeg','mov','avi','flv','mpg','webm','wmv','3gpp'];

              console.log(`[DBLClick] Checking extension against categories...`); // <<< DEBUG LOG

              const previewOnlyImageExts=['gif','bmp','svg','ico'];
              const previewOnlyAudioExts=['mp3','wav','ogg','aac','flac'];
              // basicPreviewTextExts removed as they are now in llmDocExts for RAG

              const allKnownImageExts = llmImageExts.concat(previewOnlyImageExts);

              // Determine Action based on file type
              if (llmImageExts.includes(fileExt) || llmVideoExts.includes(fileExt)) {
                  // ACTION: Open Preview + Chat UI for Image/Video
                  console.log(`[DBLClick] Action: Opening Preview+Chat for LLM ${llmImageExts.includes(fileExt) ? 'Image' : 'Video'}`); // <<< DEBUG LOG
                  console.log(`Opening Preview+Chat for LLM ${llmImageExts.includes(fileExt) ? 'Image' : 'Video'}: ${fileName}`);
                  const instanceId = `file-chat-${instanceCounter++}`;
                  const instanceType = llmImageExts.includes(fileExt) ? 'media' : 'video';
                  const instanceElements = createPreviewChatInstance(instanceId, fileName, relPath, instanceType); // <<< Pass 'video' type & get elements

                  // <<< Initiate video processing if it's a video file >>>
                  if (instanceType === 'video') {
                      console.log(`[DBLClick] Action: Calling initiateVideoProcessing for ${instanceId}`); // <<< DEBUG LOG
                      // Pass the specific chatMessagesDiv element
                      initiateVideoProcessing(instanceId, relPath, fileName, instanceElements.messages);
                  }
              } else if (llmDocExts.includes(fileExt)) {
                  // <<< ACTION: Open Preview + Chat UI for Document (Initiate RAG Processing) >>>
                  console.log(`[DBLClick] Action: Opening Preview+Chat for LLM Document`); // <<< DEBUG LOG
                  console.log(`Initiating RAG processing for document: ${fileName}`);
                  const instanceId = `file-chat-${instanceCounter++}`;
                  createPreviewChatInstance(instanceId, fileName, relPath, 'document'); // <<< Added type hint
                  console.log(`[DBLClick] Action: Calling initiateDocumentProcessing for ${instanceId}`); // <<< DEBUG LOG
                  initiateDocumentProcessing(instanceId, relPath, fileName);

              } else if (previewOnlyImageExts.includes(fileExt)) { // <<< MODIFIED: Separate image and audio handling >>>
                   // ACTION: Open Standard Modal Preview for non-LLM IMAGE types
                  console.log(`[DBLClick] Action: Opening standard modal preview for Image`); // <<< DEBUG LOG
                  const drive = "{{ drive|urlencode }}"; const apiKey = "{{ api_key|urlencode }}"; const encodedRelPath = encodeURIComponent(relPath);
                  const previewUrl = `/preview_image/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
                  showPreviewModal('image', previewUrl, fileName);

              } else if (previewOnlyAudioExts.includes(fileExt)) { // <<< NEW: Handle Audio Files >>>
                  // ACTION: Add to Mini Player Playlist
                  console.log(`[DBLClick] Action: Adding to Mini Player playlist`);
                  const drive = "{{ drive|urlencode }}"; const apiKey = "{{ api_key|urlencode }}"; const encodedRelPath = encodeURIComponent(relPath);
                  const streamUrl = `/stream/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
                  addToPlaylistAndPlay(streamUrl, fileName); // Call the new function

              } else {
                  // ACTION: Unsupported Type
                  console.log(`[DBLClick] Action: Unsupported file type`); // <<< DEBUG LOG
                  console.log(`Unsupported file type ${fileExt}`);
                  alert('지원하지 않는 파일 형식입니다.');
              }
          }


          // --- Attach Event Listeners ---
          const treeElement = document.querySelector('.tree');
          if (treeElement) { treeElement.addEventListener('click', handleTreeClick); }
          else { console.warn("Tree element not found."); }

          // Attach File List Listeners
          if (fileListContainer) {
              fileListContainer.addEventListener('click', handleFileListSingleClick);
              fileListContainer.addEventListener('dblclick', handleFileListDoubleClick);
          } else { console.error("File list container (#file-list) not found."); }

          // Setup Main Chat Listeners
          setupMainChatListeners();

          // Initialize Main Chat UI
          if (mainChatMessages) { addMessageToChat("안녕하세요! 무엇을 도와드릴까요?", 'assistant', { messages: mainChatMessages }, null, mainChatHistory); }
          else { console.warn("Main chat messages container not found on init."); }

          // Initialize Mini Player
          initMiniPlayer(); // <<< ADD THIS CALL

          // Setup Search Listener
          const searchInput = document.getElementById('searchInput');
          let searchTimeout;
          if (searchInput) {
              searchInput.addEventListener('input', () => {
                  clearTimeout(searchTimeout);
                  searchTimeout = setTimeout(() => {
                      const q = searchInput.value.toLowerCase();
                      document.querySelectorAll('#file-list .file-entry').forEach(el => {
                          // Keep 'Up' directory visible
                          if (el.querySelector('.file-icon')?.textContent === '⤴️') {
                               el.style.display = 'flex';
                               return;
                           }
                           // Filter files/folders based on name
                          // Ensure this logic correctly handles files vs folders if needed
                          const nameEl = el.querySelector('.file-name') || el.querySelector('a.folder-link'); // Handle both files and folders
                          const name = nameEl ? nameEl.textContent.toLowerCase() : '';
                          el.style.display = name.includes(q) ? 'flex' : 'none';
                      });
                  }, 200);
              });
          } else { console.warn("Search input not found."); }

          // Setup Drag & Drop Listeners
          const dropArea = document.getElementById('drop-area');
          if (dropArea) {
              ['dragenter','dragover','dragleave','drop'].forEach(ev=>dropArea.addEventListener(ev,preventDefaults,false));
              ['dragenter','dragover'].forEach(ev=>dropArea.addEventListener(ev,()=>dropArea.classList.add('highlight'),false));
              ['dragleave','drop'].forEach(ev=>dropArea.addEventListener(ev,()=>dropArea.classList.remove('highlight'),false));
              dropArea.addEventListener('drop',handleDrop,false);
              // Prevent default browser drag/drop behavior on the body
              ['dragenter','dragover','drop'].forEach(ev=>document.body.addEventListener(ev,preventDefaults,false));

              const dropAreaFileInput = dropArea.querySelector('input[type="file"]');
              if (dropAreaFileInput) {
                  dropAreaFileInput.addEventListener('change', function() { if (this.files.length > 0) { handleFiles(this.files); } });
              }
          }

          // Initial File List Load
          const initialPath = new URLSearchParams(window.location.search).get('path') || '';
          loadFileList(initialPath);

      }); // ====== End DOMContentLoaded ======

      // --- >>> NEW Function to initiate document processing (Reverted) <<< ---
      async function initiateDocumentProcessing(instanceId, relPath, fileName) {
          const instance = fileChatInstances[instanceId];
          if (!instance || !instance.elements?.messages || !instance.elements.input || !instance.elements.sendButton) {
              console.error(`initDocProc: Instance ${instanceId} or critical elements missing.`);
              if (instance?.elements?.messages) {
                  addMessageToChat("오류: 문서 처리 UI 초기화 실패.", 'assistant', instance.elements);
              }
              return;
          }

          const chatElements = instance.elements;
          const processingMessageText = "문서 분석 및 벡터화 작업 중..."; // <<< 수정: 간단한 텍스트 사용

          // Display processing message and disable input
          addMessageToChat(processingMessageText, 'assistant', chatElements, null, null); // <<< 수정: 히스토리에 추가 안 함, 클래스 제거
          const processingMsgElement = chatElements.messages.lastElementChild; // 참조 유지
          if (processingMsgElement) { // 스타일 직접 적용
               processingMsgElement.style.fontStyle = 'italic';
               processingMsgElement.style.opacity = '0.8';
          }

          chatElements.input.disabled = true;
          chatElements.sendButton.disabled = true;
          if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 내용 분석 중...</span>';

          try {
              const apiKey = "{{ api_key|urlencode }}";
              const response = await fetch('/process_document', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Api-Key': apiKey
                  },
                  body: JSON.stringify({
                instanceId: instanceId,
                relPath: relPath,
                fileName: fileName,
                drive: "{{ drive }}" // <<< 이 부분을 추가해주세요
            })
              });

              // <<< 처리중 메시지 제거 >>>
              if (processingMsgElement && chatElements.messages.contains(processingMsgElement)) {
                   processingMsgElement.remove();
              }

              if (response.ok) {
                  const result = await response.json();
                  console.log(`Document processing succeeded for ${instanceId}:`, result.message);
                  addMessageToChat(`✅ ${result.message || '문서 처리 완료.'} 이제 문서에 대해 질문할 수 있습니다.`, 'assistant', chatElements, null, instance.history);
                   if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 완료.</span>';
                   loadPreviewContent(instanceId, relPath, fileName);
              } else { // <<< 수정: 503 처리 제거, 일반 오류 처리 >>>
                  const result = await response.json().catch(() => ({ error: `서버 오류 (상태: ${response.status})` }));
                  console.error(`Document processing failed for ${instanceId}:`, result.error || response.statusText);
                  addMessageToChat(`❌ 문서 처리 실패: ${result.error || response.statusText}. 채팅 기능이 제한될 수 있습니다.`, 'assistant', chatElements, null, instance.history);
                   if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 실패.</span>';
              }

          } catch (error) { // <<< 수정: 처리중 메시지 제거 추가 >>>
              if (processingMsgElement && chatElements.messages.contains(processingMsgElement)) {
                   processingMsgElement.remove();
              }
              console.error(`Error calling /process_document for ${instanceId}:`, error);
              addMessageToChat(`❌ 문서 처리 요청 중 오류 발생: ${error.message}.`, 'assistant', chatElements, null, instance.history);
              if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 중 오류 발생.</span>';
          } finally {
              // <<< 수정: finally 블록에서 입력 활성화 >>>
              chatElements.input.disabled = false;
              chatElements.sendButton.disabled = false;
              console.log(`Input re-enabled for instance ${instanceId} after document processing attempt.`);
          }
      }

      // --- >>> NEW Functions for Video Processing <<< ---
      async function initiateVideoProcessing(instanceId, relPath, fileName, chatMessagesDiv) { // <<< Receive chatMessagesDiv as argument
          // Display processing message
          const processingMessage = document.createElement('div');
          processingMessage.className = 'processing-message'; // Assign a class for potential styling
          processingMessage.textContent = '비디오 처리 요청 중...'; // Add text content
          chatMessagesDiv.appendChild(processingMessage);

          // Ensure chat elements are available for adding messages later
          const instance = fileChatInstances[instanceId];
          const chatElements = instance ? instance.elements : { messages: chatMessagesDiv }; // Fallback if instance lookup fails unexpectedly

          if (!chatElements.messages) {
             console.error("initiateVideoProcessing: chatMessagesDiv is not valid or instance elements missing.");
             // Try removing the processing message if it was added
             if (processingMessage.parentNode === chatMessagesDiv) {
                 chatMessagesDiv.removeChild(processingMessage);
             }
             return; // Cannot proceed without a valid message container
          }


          try {
              const response = await fetch('/process_video', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Api-Key': "{{ api_key|urlencode }}"
                  },
                  // <<< ADD drive parameter >>>
                  body: JSON.stringify({ instanceId, relPath, fileName, drive: "{{ drive }}" })
              });

              // Remove processing message *before* adding the result/error message
              if (processingMessage.parentNode === chatMessagesDiv) {
                  chatMessagesDiv.removeChild(processingMessage);
              }

              if (response.ok) {
                  const result = await response.json();
                  console.log("Video processing initiated/completed:", result);
                  // <<< Use addMessageToChat instead of appendMessage >>>
                  addMessageToChat(result.message || "비디오 처리가 완료되었습니다. 이제 질문할 수 있습니다.", 'assistant', chatElements, null, instance?.history);
              } else {
                  const errorResult = await response.json().catch(() => ({ error: `영상 처리 중 서버 오류 (Status: ${response.status})` }));
                  const errorText = errorResult.error || `영상 처리 중 오류 발생 (Status: ${response.status})`;
                  console.error("Video processing error response:", errorResult);
                  // <<< Use addMessageToChat instead of appendMessage >>>
                  addMessageToChat(`❌ 오류: ${errorText}`, 'assistant', chatElements, null, instance?.history);
              }
          } catch (error) {
               // Remove processing message *before* adding the error message
              if (processingMessage.parentNode === chatMessagesDiv) {
                  chatMessagesDiv.removeChild(processingMessage);
              }
              console.error("Error calling /process_video:", error);
              // <<< Use addMessageToChat instead of appendMessage >>>
              addMessageToChat(`❌ 클라이언트 측 오류: ${error.message}`, 'assistant', chatElements, null, instance?.history);
          } finally {
              // Re-enable input regardless of outcome (ensure elements exist)
              // Note: Input/Send buttons are part of chatElements if instance exists
              if (chatElements.input) chatElements.input.disabled = false;
              if (chatElements.sendButton) chatElements.sendButton.disabled = false;
          }
      }

    </script>

    <!-- Mini Audio Player -->
    <div id="mini-audio-player" style="display: none;">
        <div class="mini-player-content">
            <span id="mini-player-title">Now Playing...</span>
            <div class="mini-player-controls">
                <button id="mini-player-prev" title="Previous (Not Implemented)">⏮️</button>
                <button id="mini-player-playpause" title="Play/Pause">▶️</button>
                <button id="mini-player-next" title="Next">⏭️</button>
                <!-- Volume Control -->
                <input type="range" id="mini-player-volume" title="Volume" min="0" max="1" step="0.05" value="1">
            </div>
            <div class="mini-player-progress-container">
                 <input type="range" id="mini-player-progress" value="0" min="0" max="100">
            </div>
             <span id="mini-player-time">0:00 / 0:00</span>
             <!-- Playlist Display Area -->
             <ul id="mini-player-playlist"></ul>
        </div>
        <button id="mini-player-close" title="Close Player">&times;</button>
    </div>

</body>
</html>