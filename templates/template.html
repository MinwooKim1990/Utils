<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minwoo의 파일 탐색기</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <!-- Add Marked.js library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add DOMPurify library for sanitization -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>
</head>
<body>
    <div class="sidebar">
      <div class="drive-selector">
        {% for drv in allowed_drives %}
          <a href="/?drive={{ drv }}&api_key={{ api_key }}" class="{% if drv == drive %}selected{% endif %}">{{ drv[:-2] }}</a>
        {% endfor %}
      </div>
      <h4>📁 탐색기</h4>
      <div class="tree">
        {{ tree_html|safe }}
      </div>
    </div>
    <div class="content">
      <div class="top-bar">
        <div class="nav-buttons">
          <button onclick="goBack()">⏪ 뒤로</button>
          <button onclick="goForward()">⏩ 앞으로</button>
        </div>
        <div class="search-bar">
          🔍 <input type="text" id="searchInput" oninput="searchFiles()" placeholder="파일명 검색...">
        </div>
        <div class="sort-buttons">
          <span>정렬:</span>
          {% set opposite_dir = 'desc' if sort_dir == 'asc' else 'asc' %}
          {% set name_dir = opposite_dir if sort_param == 'name' else 'asc' %}
          {% set date_dir = opposite_dir if sort_param == 'date' else 'asc' %}
          {% set size_dir = opposite_dir if sort_param == 'size' else 'asc' %}
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=name&dir={{ name_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'name' %}selected{% endif %}">
             이름 {% if sort_param == 'name' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=date&dir={{ date_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'date' %}selected{% endif %}">
             날짜 {% if sort_param == 'date' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=size&dir={{ size_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'size' %}selected{% endif %}">
             크기 {% if sort_param == 'size' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
        </div>
      </div>
      <div class="location-bar">
        <h3>📂 현재 위치 (드라이브: {{ drive[:-2] }}): {{ current_path or '/' }}</h3>
      </div>

      <!-- New Wrapper for File List and Chat -->
      <div class="content-wrapper">
        <!-- Existing File Content Area -->
        <div class="main-content">
            <div id="file-list" class="file-list">
                {% if is_search %}
                    <h2>Search Results for "{{ search_query }}" in {{ current_path or 'root' }}</h2>
                    {% include 'search_results.html' %}
                {% else %}
                    <h2>Files in {{ current_path or 'root' }}</h2>
                    {% include 'file_list.html' %}
                {% endif %}
            </div>
            <!-- 드래그 앤 드롭 업로드 영역 -->
            <div id="drop-area">
                <p>파일을 여기에 끌어다 놓으세요.</p>
                <p>또는 아래 버튼을 사용하여 파일을 선택할 수 있습니다.</p>
                <form method="POST" action="/upload?drive={{ drive }}&api_key={{ api_key }}&path={{ current_path }}" enctype="multipart/form-data">
                    <input type="file" name="file">
                    <button type="submit">업로드</button>
                </form>
                <div id="upload-progress"></div>
            </div>
        </div>

        <!-- New Chat Interface Area -->
        <div id="chat-container">
            <div id="chat-header">
                <h4>💬 Gemini Chat</h4>
                <button id="refresh-chat-button" title="새 대화 시작">🔄</button>
            </div>
            <!-- Model Selector Dropdown -->
            <div class="model-selector">
                <label for="model-select">모델 선택:</label>
                <select id="model-select">
                    <option value="gemini-2.0-flash-lite" selected>gemini-2.0-flash-lite</option>
                    <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                    <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                </select>
            </div>
            <div id="chat-messages">
                <!-- Chat messages will appear here -->
            </div>
            <!-- Image preview area -->
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <span id="image-filename"></span>
                <button id="remove-image-button" title="이미지 제거">&times;</button>
            </div>
            <!-- Mic status indicator -->
            <span id="mic-status"></span>
            <div id="chat-input-area">
                <!-- Hidden file input -->
                <input type="file" id="image-upload" accept="image/*">
                <!-- Image upload button -->
                <button id="image-upload-button" title="이미지 첨부">🖼️</button>
                <!-- Mic button -->
                <button id="mic-button" title="음성 입력">🎤</button>
                <input type="text" id="chat-input" placeholder="메시지를 입력하세요...">
                <button id="send-button">전송</button>
            </div>
        </div>
      </div>
      <!-- End New Wrapper -->

    </div> <!-- End .content -->

    <!-- Preview Modal Overlay -->
    <div id="preview-overlay" style="display: none;">
      <button id="preview-close-btn">&times;</button>
      <div id="preview-content">
          <!-- Add video element here -->
          <video id="preview-video" controls style="display: none; max-width: 100%; max-height: 80vh;"></video>
          <!-- Existing preview elements might be here, ensure they are hidden when video shows -->
          <img id="preview-image" style="display: none; max-width: 100%; max-height: 80vh;" />
          <pre id="preview-text" style="display: none; white-space: pre-wrap; word-wrap: break-word;"></pre>
          <div id="preview-pdf" style="display: none; width: 100%; height: 80vh;"></div>
          <!-- Add other preview types if needed -->
      </div>
      <div id="preview-filename"></div>
    </div>

    <script>
      // --- Preview Modal Elements (For Preview-Only Files) --- START
      const previewOverlay = document.getElementById('preview-overlay');
      const previewContent = document.getElementById('preview-content');
      const previewCloseBtn = document.getElementById('preview-close-btn');
      const previewFilename = document.getElementById('preview-filename');
      // --- Preview Modal Elements --- END

      // --- Preview Modal Functions (For Preview-Only Files) --- START
      function showPreviewModal(fileType, url, fileName) {
          if (!previewOverlay || !previewContent || !previewFilename || !previewCloseBtn) { console.error("Preview modal elements missing."); alert("Preview error."); return; }
          previewContent.innerHTML = '<span class="preview-placeholder">Loading preview...</span>';
          previewFilename.textContent = fileName;
          let element;
          if (fileType === 'video') { element = document.createElement('video'); element.controls = true; element.autoplay = true; element.style.maxWidth = '90vw'; element.style.maxHeight = '80vh'; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Video load failed.</p>'; }; }
          else if (fileType === 'audio') { element = document.createElement('audio'); element.controls = true; element.autoplay = true; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Audio load failed.</p>'; }; }
          else if (fileType === 'image') { element = document.createElement('img'); element.style.maxWidth = '90vw'; element.style.maxHeight = '80vh'; element.style.display = 'block'; element.style.margin = 'auto'; element.alt = fileName; element.src = url; element.onerror = () => { previewContent.innerHTML = '<p>Image load failed.</p>'; }; }
          else if (fileType === 'text' || fileType === 'pdf') { element = document.createElement('iframe'); element.style.width = '90vw'; element.style.height = '80vh'; element.style.border = 'none'; element.style.backgroundColor = 'var(--card, #fff)'; element.src = url; element.onload = () => console.log("Modal iframe loaded."); element.onerror = () => { previewContent.innerHTML = '<p>Preview load failed.</p>'; }; }
          if (element) { previewContent.innerHTML = ''; previewContent.appendChild(element); previewOverlay.style.display = 'flex'; }
          else { console.error("Could not create preview element for type:", fileType); previewContent.innerHTML = '<p>Cannot create preview element.</p>'; previewOverlay.style.display = 'flex'; }
      }
      function closePreviewModal() { if (!previewOverlay || !previewContent) return; previewOverlay.style.display = 'none'; const media = previewContent.querySelector('video, audio'); if (media) { media.pause(); media.src = ''; } const iframe = previewContent.querySelector('iframe'); if (iframe) iframe.src = 'about:blank'; previewContent.innerHTML = ''; if (previewFilename) previewFilename.textContent = ''; }
      if (previewCloseBtn) previewCloseBtn.addEventListener('click', closePreviewModal);
      if (previewOverlay) previewOverlay.addEventListener('click', function(e) { if (e.target === previewOverlay) closePreviewModal(); });
      // --- Preview Modal Functions --- END

      // --- Global Variables & Initial Setup ---
      const MAX_HISTORY_LENGTH = 10;
      const fileChatInstances = {};
      let instanceCounter = 0;

      // --- DOM Element References (Main Chat) ---
      const mainChatContainer = document.getElementById('chat-container');
      const mainChatMessages = document.getElementById('chat-messages');
      const mainChatInput = document.getElementById('chat-input');
      const mainSendButton = document.getElementById('send-button');
      const mainModelSelect = document.getElementById('model-select');
      const mainImageUploadButton = document.getElementById('image-upload-button');
      const mainImageUploadInput = document.getElementById('image-upload');
      const mainImagePreviewArea = document.getElementById('image-preview-area');
      const mainImagePreview = document.getElementById('image-preview');
      const mainImageFilename = document.getElementById('image-filename');
      const mainRemoveImageButton = document.getElementById('remove-image-button');
      const mainMicButton = document.getElementById('mic-button');
      const mainMicStatus = document.getElementById('mic-status');
      const mainRefreshChatButton = document.getElementById('refresh-chat-button');
      const fileListContainer = document.getElementById('file-list');

      // --- Main Chat History & State ---
      let mainChatHistory = [];
      let mainAttachedImageData = null;
      let mainMediaRecorder;
      let mainAudioChunks = [];
      let isMainRecording = false;

      // --- Mini Audio Player Logic --- START
      let miniPlayer = null;
      let miniPlayerAudio = null; // HTMLAudioElement
      let miniPlayerTitle = null;
      let miniPlayerPlayPauseBtn = null;
      let miniPlayerNextBtn = null;
      let miniPlayerPrevBtn = null;
      let miniPlayerCloseBtn = null;
      let miniPlayerProgress = null;
      let miniPlayerTime = null;
      let miniPlayerVolume = null; // <<< Volume slider element
      let miniPlayerPlaylistElement = null; // <<< Playlist UL element

      let audioPlaylist = []; // Array of {url: string, title: string}
      let currentTrackIndex = -1;
      let isMiniPlayerSeeking = false; // <<< Seeking flag

      // Function to save player state to localStorage
      function savePlayerState() {
          if (!miniPlayerAudio || audioPlaylist.length === 0 || currentTrackIndex < 0) {
               localStorage.removeItem('miniPlayerState'); // Clear if nothing is playing
               return;
           }
          const state = {
              playlist: audioPlaylist,
              index: currentTrackIndex,
              time: miniPlayerAudio.currentTime,
              volume: miniPlayerAudio.volume,
              paused: miniPlayerAudio.paused // Save paused state
          };
          try {
              localStorage.setItem('miniPlayerState', JSON.stringify(state));
          } catch (e) {
              console.error("Error saving player state to localStorage:", e);
          }
      }

      // Function to load player state from localStorage
      function loadPlayerState() {
          try {
              const savedState = localStorage.getItem('miniPlayerState');
              if (savedState) {
                  const state = JSON.parse(savedState);
                  // Basic validation
                  if (state && Array.isArray(state.playlist) && typeof state.index === 'number' && state.index >= 0 && state.index < state.playlist.length) {
                      audioPlaylist = state.playlist;
                      currentTrackIndex = state.index;

                      // Load the track but don't auto-play immediately from localStorage restore
                      const track = audioPlaylist[currentTrackIndex];
                       if(track && track.url) {
                            miniPlayerAudio.src = track.url;
                            miniPlayerTitle.textContent = track.title;
                            // Restore time only if duration is available (might need small delay or check in loadedmetadata)
                            miniPlayerAudio.addEventListener('loadedmetadata', () => {
                                if (!isNaN(miniPlayerAudio.duration) && state.time < miniPlayerAudio.duration) {
                                    miniPlayerAudio.currentTime = state.time;
                                }
                                miniPlayerProgress.max = miniPlayerAudio.duration || 100;
                                miniPlayerProgress.value = miniPlayerAudio.currentTime;
                                updatePlayerUI(); // Update UI after metadata loaded
                                // Restore paused state
                                if (state.paused) {
                                    miniPlayerAudio.pause();
            } else {
                                    // Optional: Auto-play if it wasn't paused? Decide based on desired UX
                                    // miniPlayerAudio.play().catch(e => console.error("Autoplay from restore failed:", e));
                                }
                                updatePlayerUI();
                            }, { once: true }); // Ensure listener only runs once per load

                            // Restore volume
                            if (typeof state.volume === 'number' && state.volume >= 0 && state.volume <= 1) {
                                miniPlayerAudio.volume = state.volume;
                                if (miniPlayerVolume) miniPlayerVolume.value = state.volume;
                            }

                            showMiniPlayer();
                            console.log("Restored player state from localStorage:", state);
                } else {
                           console.warn("Invalid track data in saved state.");
                           localStorage.removeItem('miniPlayerState');
                       }

                  } else {
                      console.log("Invalid saved player state found, clearing.");
                      localStorage.removeItem('miniPlayerState');
                  }
              } else {
                  console.log("No saved player state found.");
              }
          } catch (e) {
              console.error("Error loading player state from localStorage:", e);
              localStorage.removeItem('miniPlayerState'); // Clear corrupted state
          }
      }


      function formatTime(seconds) {
          const minutes = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
      }

      function initMiniPlayer() {
          miniPlayer = document.getElementById('mini-audio-player');
          miniPlayerTitle = document.getElementById('mini-player-title');
          miniPlayerPlayPauseBtn = document.getElementById('mini-player-playpause');
          miniPlayerNextBtn = document.getElementById('mini-player-next');
          miniPlayerPrevBtn = document.getElementById('mini-player-prev');
          miniPlayerCloseBtn = document.getElementById('mini-player-close');
          miniPlayerProgress = document.getElementById('mini-player-progress');
          miniPlayerTime = document.getElementById('mini-player-time');
          miniPlayerVolume = document.getElementById('mini-player-volume'); // <<< Get volume slider
          miniPlayerPlaylistElement = document.getElementById('mini-player-playlist'); // <<< Get playlist UL

          if (!miniPlayer || !miniPlayerTitle || !miniPlayerPlayPauseBtn || !miniPlayerNextBtn || !miniPlayerCloseBtn || !miniPlayerProgress || !miniPlayerTime || !miniPlayerVolume || !miniPlayerPlaylistElement) { // <<< Check playlist element
              console.error("Mini Player elements not found!");
              return;
          }

          miniPlayerAudio = new Audio();

          // Event Listeners for Audio Element
          miniPlayerAudio.addEventListener('loadedmetadata', () => {
              if (!isNaN(miniPlayerAudio.duration)) {
                   miniPlayerProgress.max = miniPlayerAudio.duration;
                   updatePlayerUI();
              }
          });
          miniPlayerAudio.addEventListener('timeupdate', () => {
              if (!isMiniPlayerSeeking && !isNaN(miniPlayerAudio.duration)) {
                  miniPlayerProgress.value = miniPlayerAudio.currentTime;
                  updatePlayerUI();
                  savePlayerState(); // Save state periodically on time update
              }
          });
          miniPlayerAudio.addEventListener('ended', playNextTrack);
          miniPlayerAudio.addEventListener('error', (e) => {
              console.error("Mini Player Audio Error:", e);
              miniPlayerTitle.textContent = "Error loading track";
              // playNextTrack(); // Option: try next on error
          });
          miniPlayerAudio.addEventListener('play', updatePlayerUI); // Update UI on play
          miniPlayerAudio.addEventListener('pause', updatePlayerUI); // Update UI on pause


          // Event Listeners for Controls
          miniPlayerPlayPauseBtn.addEventListener('click', () => {
              if (miniPlayerAudio.paused) {
                  miniPlayerAudio.play().catch(e => console.error("Play error:", e));
              } else {
                  miniPlayerAudio.pause();
              }
              // updatePlayerUI(); // Already handled by 'play'/'pause' events
          });
          miniPlayerNextBtn.addEventListener('click', playNextTrack);
          miniPlayerPrevBtn.addEventListener('click', () => {
              console.log("Previous track functionality: jump to beginning or previous track");
              if (miniPlayerAudio.currentTime > 3 || currentTrackIndex === 0) { // If more than 3s in or first track, restart current
                 miniPlayerAudio.currentTime = 0;
              } else if (currentTrackIndex > 0) { // Go to previous track
                  loadAndPlayTrack(currentTrackIndex - 1);
              }
          });
          miniPlayerCloseBtn.addEventListener('click', hideMiniPlayer);

          // Event Listeners for Progress Bar
          miniPlayerProgress.addEventListener('input', () => {
              isMiniPlayerSeeking = true; // Set flag when user starts interacting
              if (!isNaN(miniPlayerAudio.duration)) {
                 // Update time display instantly while seeking
                 miniPlayerTime.textContent = `${formatTime(miniPlayerProgress.value)} / ${formatTime(miniPlayerAudio.duration)}`;
              }
          });
          miniPlayerProgress.addEventListener('change', () => {
              if (!isNaN(miniPlayerAudio.duration)) {
                  miniPlayerAudio.currentTime = miniPlayerProgress.value; // Set audio time when user releases slider
              }
              isMiniPlayerSeeking = false; // Reset flag
              if (!miniPlayerAudio.paused) { // If it was playing, resume playback
                 miniPlayerAudio.play().catch(e => console.error("Seek->Play error:", e));
              }
              updatePlayerUI(); // Update button state etc.
          });

          // <<< Volume Control Listener >>>
          miniPlayerVolume.addEventListener('input', () => {
              miniPlayerAudio.volume = miniPlayerVolume.value;
              savePlayerState(); // Save volume change
          });

          console.log("Mini Player Initialized.");
          // Attempt to load state after initialization
          loadPlayerState();
      }

      // <<< NEW Function to update playlist UI >>>
      function updatePlaylistUI() {
          if (!miniPlayerPlaylistElement || !audioPlaylist) {
               console.log("[updatePlaylistUI] Skipping: Element or playlist not ready.");
               return;
           }
          miniPlayerPlaylistElement.innerHTML = ''; // Clear existing list

          if (audioPlaylist.length === 0) {
               miniPlayerPlaylistElement.style.display = 'none'; // Hide if empty
               return;
           }
           miniPlayerPlaylistElement.style.display = 'block'; // Show if not empty

          audioPlaylist.forEach((track, index) => {
              const li = document.createElement('li');
              li.textContent = track.title;
              li.title = track.title; // Tooltip for long names
              li.dataset.index = index;
              if (index === currentTrackIndex) {
                  li.classList.add('playing');
              }
              li.addEventListener('click', () => {
                  console.log(`[Playlist Click] Clicked index ${index}`);
                  loadAndPlayTrack(index);
              });
              miniPlayerPlaylistElement.appendChild(li);
          });
          console.log("[updatePlaylistUI] Playlist UI updated.");
      }

      function showMiniPlayer() {
          if (miniPlayer) miniPlayer.style.display = 'flex';
          updatePlaylistUI(); // <<< Update playlist when showing player
      }

      function hideMiniPlayer() {
          if (miniPlayer) miniPlayer.style.display = 'none';
          if (miniPlayerAudio) {
              miniPlayerAudio.pause(); // <<< Pause first
              miniPlayerAudio.src = ''; // Then clear src
          }
          audioPlaylist = [];
          currentTrackIndex = -1;
          if (miniPlayerTitle) miniPlayerTitle.textContent = "Now Playing...";
          if (miniPlayerProgress) miniPlayerProgress.value = 0;
          if (miniPlayerTime) miniPlayerTime.textContent = "0:00 / 0:00";
          if (miniPlayerPlayPauseBtn) miniPlayerPlayPauseBtn.textContent = '▶️';
          localStorage.removeItem('miniPlayerState'); // <<< Clear saved state on close
          if (miniPlayerPlaylistElement) miniPlayerPlaylistElement.innerHTML = ''; // <<< Clear playlist UI
          console.log("Mini Player Hidden and State Cleared.");
      }

      function addToPlaylistAndPlay(url, title) {
           if (!miniPlayerAudio) {
               console.error("Audio element not initialized.");
               return;
           }
          const newTrack = { url, title };
          let trackAlreadyExists = false;
          // Check if the exact track already exists anywhere in the playlist
          for(let i = 0; i < audioPlaylist.length; i++) {
              if(audioPlaylist[i].url === url && audioPlaylist[i].title === title) {
                  trackAlreadyExists = true;
                  console.log(`Track "${title}" already in playlist at index ${i}.`);
                  break;
              }
          }

          // Only add if it doesn't exist
          if (!trackAlreadyExists) {
              audioPlaylist.push(newTrack);
              console.log(`Added to playlist: ${title}. New length: ${audioPlaylist.length}`);
          }

          // <<< CHANGE: Only play immediately if player is idle >>>
          // Check if player is not playing (index is -1 OR it's paused and at the beginning)
          const isPlayerIdle = currentTrackIndex === -1 || (miniPlayerAudio.paused && miniPlayerAudio.currentTime === 0);

          if (isPlayerIdle && audioPlaylist.length > 0) {
              // If idle, play the *last added* track (which might be the only one)
              const targetIndex = audioPlaylist.length - 1;
              console.log(`Player is idle, playing newly added track at index ${targetIndex}: ${audioPlaylist[targetIndex].title}`);
              loadAndPlayTrack(targetIndex);
          } else if (!isPlayerIdle) {
              console.log(`Player is currently active. Added "${title}" to queue. It will play after the current track finishes.`);
              // If player is active, just ensure UI reflects potential playlist changes (e.g., if implementing a visible playlist later)
              updatePlaylistUI(); // <<< Update UI when adding to queue
          }

          showMiniPlayer(); // Make sure player is visible regardless
      }

       function loadAndPlayTrack(index) {
          if (index < 0 || index >= audioPlaylist.length || !miniPlayerAudio) {
              console.log("Invalid track index or playlist empty.");
              // Don't hide player here automatically, might just be an invalid index attempt
              return;
          }
          currentTrackIndex = index;
          const track = audioPlaylist[currentTrackIndex];
          console.log(`Loading track ${index}: ${track.title}`);

          // Pause current playback before changing src
          miniPlayerAudio.pause();

          miniPlayerAudio.src = track.url;
          miniPlayerTitle.textContent = track.title;
          miniPlayerProgress.value = 0;
          miniPlayerAudio.load(); // Important: load the new source
          miniPlayerAudio.play()
              .then(() => {
                   updatePlayerUI();
                   savePlayerState(); // Save state after starting new track
              })
              .catch(e => {
                   console.error("Error playing track:", e);
                   miniPlayerTitle.textContent = "Error playing";
                   updatePlayerUI();
                   savePlayerState(); // Save state even if error occurred
               });
           updatePlaylistUI(); // <<< Update playlist UI when loading a new track
           showMiniPlayer(); // Ensure player is visible when loading a track
      }

      function playNextTrack() {
           // Play the next index in the current playlist array
           const nextIndex = currentTrackIndex + 1;
           if (nextIndex < audioPlaylist.length) {
              loadAndPlayTrack(nextIndex);
           } else {
              console.log("End of playlist reached.");
              // Optionally loop back to the start?
              // loadAndPlayTrack(0);
              // Or just stop and hide:
              hideMiniPlayer();
           }
           updatePlaylistUI(); // <<< Update playlist UI state
           // Volume is handled by its own event listener + state loading
      }

      function updatePlayerUI() {
          if (!miniPlayerAudio || !miniPlayerPlayPauseBtn || !miniPlayerTime || !miniPlayerProgress || !miniPlayerTitle) return;

          miniPlayerPlayPauseBtn.textContent = miniPlayerAudio.paused ? '▶️' : '⏸️';

          const currentTime = miniPlayerAudio.currentTime || 0;
          const duration = miniPlayerAudio.duration || 0;
          if (!isNaN(duration) && duration > 0) { // Check duration > 0
              miniPlayerTime.textContent = `${formatTime(currentTime)} / ${formatTime(duration)}`;
              if (miniPlayerProgress.max != duration) {
                   miniPlayerProgress.max = duration;
              }
              // Update progress only if not seeking
              if (!isMiniPlayerSeeking) {
                   miniPlayerProgress.value = currentTime;
              }
          } else {
              miniPlayerTime.textContent = `${formatTime(currentTime)} / --:--`;
              miniPlayerProgress.max = 100; // Default max if duration unknown
               if (!isMiniPlayerSeeking) {
                   miniPlayerProgress.value = 0; // Reset if duration unknown
               }
          }

          // Update Title based on currentTrackIndex
          if (currentTrackIndex !== -1 && currentTrackIndex < audioPlaylist.length) {
               if (!miniPlayerTitle.textContent.startsWith("Error")) { // Avoid overwriting error messages
                  miniPlayerTitle.textContent = audioPlaylist[currentTrackIndex].title;
              }
          } else if (audioPlaylist.length === 0) {
               miniPlayerTitle.textContent = "Now Playing...";
           }
           // Volume is handled by its own event listener + state loading
      }
      // --- Mini Audio Player Logic --- END

      // --- Utility Functions ---
      function formatFileSize(bytes) { if (bytes === 0) return '0 Bytes'; const k = 1024; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + ['Bytes', 'KB', 'MB', 'GB', 'TB'][i]; }
      function pruneHistory(historyArray) { const max = MAX_HISTORY_LENGTH * 2; return historyArray.length > max ? historyArray.slice(historyArray.length - max) : historyArray; }

      // --- Tree Navigation Function ---
      function toggleChildren(el) { const li = el.parentElement; let ul = li.querySelector('ul'); if (!ul) return; if (ul.innerHTML.trim() === "") { const path = li.querySelector('.folder-link')?.getAttribute('data-path'); if(!path) return; fetch(`/folder_children?drive={{ drive }}&api_key={{ api_key|urlencode }}&path=${encodeURIComponent(path)}`).then(r => r.text()).then(h => { ul.innerHTML = h; ul.style.display = 'block'; li.classList.add('expanded'); el.textContent = '🔽'; }).catch(e => console.error('FC fetch err:', e)); } else { const d = ul.style.display; ul.style.display = (d === 'none' || d === '') ? 'block' : 'none'; li.classList.toggle('expanded', ul.style.display === 'block'); el.textContent = (ul.style.display === 'block') ? '🔽' : '▶️'; } }

      // --- File List Loading Function ---
      function loadFileList(path) {
          const drive = "{{ drive }}";
          const api_key = "{{ api_key|urlencode }}";
          const params = new URLSearchParams(window.location.search);
          const sort = params.get('sort') || 'name';
          const dir = params.get('dir') || 'asc';
          fetch(`/filelist?drive=${encodeURIComponent(drive)}&api_key=${encodeURIComponent(api_key)}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}`)
              .then(r => { if (!r.ok) throw new Error(`HTTP error! status: ${r.status}`); return r.text(); })
              .then(h => {
                  if (!fileListContainer) { console.error("File list container not found during loadFileList."); return; }
                  fileListContainer.innerHTML = h;
                  const loc = document.querySelector('.location-bar h3');
                  if(loc) loc.textContent = `📂 (${drive.slice(0,-2)}): ${path || '/'}`;
                  const btns = document.querySelectorAll('.sort-buttons a');
                  const n=(s,d)=>(s==='name'?(d==='asc'?'desc':'asc'):'asc');
                  const dt=(s,d)=>(s==='date'?(d==='asc'?'desc':'asc'):'asc');
                  const sz=(s,d)=>(s==='size'?(d==='asc'?'desc':'asc'):'asc');
                  if(btns.length===3){
                      btns[0].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=name&dir=${n(sort,dir)}&api_key=${api_key}`;
                      btns[1].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=date&dir=${dt(sort,dir)}&api_key=${api_key}`;
                      btns[2].href=`/?drive=${drive}&path=${encodeURIComponent(path)}&sort=size&dir=${sz(sort,dir)}&api_key=${api_key}`;
                  }
                  const currentPath = new URLSearchParams(window.location.search).get('path') || '';
                   const decodedCurrentPath = decodeURIComponent(currentPath);
                   // Only push state if the path is actually different to avoid loop on popstate
                   if (decodedCurrentPath !== path) {
                      history.pushState({path:path}, '', `/?drive=${drive}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}&api_key=${api_key}`);
                   }
              })
              .catch(e => console.error('FL load failed:', e));
       }

      // --- Browser History Functions ---
      function goBack() { history.back(); }
      function goForward() { history.forward(); }
      window.addEventListener('popstate', (e) => {
          const p = e.state?.path ?? (new URLSearchParams(location.search).get('path') || '');
          loadFileList(p); // Reload file list based on history state
      });

      // --- Drag & Drop Upload Functions ---
      function preventDefaults(e){e.preventDefault();e.stopPropagation();}
      function handleDrop(e){ const dt=e.dataTransfer; const files=dt.files; if(files.length) handleFiles(files); }
      function handleFiles(files){ [...files].forEach(uploadFile); }
      function uploadFile(file){
          const url = `/upload?drive={{ drive }}&api_key={{ api_key|urlencode }}&path={{ current_path }}`; // Ensure current_path is available
          const fd=new FormData(); fd.append('file',file);
          const xhr=new XMLHttpRequest(); xhr.open('POST',url,true);
          const pCont=document.getElementById('upload-progress');
          const pItem=document.createElement('div'); pItem.className='progress-item';
          pItem.innerHTML=`<div>${file.name} (${formatFileSize(file.size)})</div><div class="progress-bar"></div>`;
          if(pCont) pCont.appendChild(pItem);
          const pBar=pItem.querySelector('.progress-bar');
          xhr.upload.onprogress=ev=>{if(ev.lengthComputable&&pBar)pBar.style.width=((ev.loaded/ev.total)*100)+'%'};
          xhr.onload=()=>{
              if(xhr.status>=200&&xhr.status<300){
                  if(pBar) pBar.style.width='100%'; pItem.style.backgroundColor='#10b981';
                  setTimeout(()=>{pItem.remove(); if(pCont&&pCont.children.length===0) loadFileList("{{ current_path }}");}, 1000); // Reload on success
        } else {
                  pItem.style.backgroundColor='#ef4444'; pItem.innerHTML+=`<div style="color:var(--danger);margin-top:8px;">Fail: ${xhr.statusText||'Err'}</div>`;
                  setTimeout(()=>pItem.remove(), 3000);
              }
          };
          xhr.onerror=()=>{
              pItem.style.backgroundColor='#ef4444'; pItem.innerHTML+=`<div style="color:var(--danger);margin-top:8px;">Net Err.</div>`;
              setTimeout(()=>pItem.remove(), 3000);
          };
          xhr.send(fd);
      }

      // --- Main Chat Event Listeners Setup Function ---
       function setupMainChatListeners() {
          if(mainSendButton) mainSendButton.addEventListener('click', () => sendMessage());
          if(mainChatInput) mainChatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { sendMessage(); e.preventDefault(); } });
          if(mainImageUploadButton) mainImageUploadButton.addEventListener('click', () => { if (mainMicButton?.classList.contains('recording')) return; mainImageUploadInput?.click(); });
          if(mainImageUploadInput) mainImageUploadInput.addEventListener('change', handleMainImageFileSelect);
          if(mainRemoveImageButton) mainRemoveImageButton.addEventListener('click', clearMainAttachedImage);
          if(mainRefreshChatButton) mainRefreshChatButton.addEventListener('click', clearMainChat);
          if (mainMicButton) mainMicButton.addEventListener('click', toggleMainRecording);
      }

      // --- Chat Functionality (Common & Main) ---
      function addMessageToChat(message, sender, chatElements, imageUrl = null, historyArray = null) { if (!chatElements?.messages) { console.error("addMsg: No messages element"); return; } const el = document.createElement('div'); el.classList.add('message', sender==='user'?'user-message':'assistant-message'); if (sender==='assistant') { marked.setOptions({breaks:true}); el.innerHTML=DOMPurify.sanitize(marked.parse(message)); } else { el.textContent=message; } if (sender==='user' && imageUrl) { const img=document.createElement('img'); img.src=imageUrl; img.alt="Attached"; img.classList.add('attached-image-thumb'); el.appendChild(img); } chatElements.messages.appendChild(el); requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); if(historyArray){ const entry={role:(sender==='user'?'user':'model'),parts:[]}; if(message) entry.parts.push({text:message}); if(entry.parts.length>0){ historyArray.push(entry); const pruned=pruneHistory(historyArray); if(pruned!==historyArray){ historyArray.length=0; historyArray.push(...pruned); }}} }
      function updateLastAssistantMessage(textChunk, chatElements) { if (!chatElements?.messages) return; let last=chatElements.messages.querySelector('.assistant-message:last-child'); if(!last || last.dataset.streaming !== 'true'){ last=document.createElement('div'); last.className='message assistant-message'; last.dataset.streaming='true'; chatElements.messages.appendChild(last); } last.textContent += textChunk; requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); }
      function finalizeLastAssistantMessage(chatElements, historyArray) { if (!chatElements?.messages) return; let last=chatElements.messages.querySelector('.assistant-message:last-child[data-streaming="true"]'); if(last){ delete last.dataset.streaming; const txt=last.textContent; marked.setOptions({breaks:true}); last.innerHTML=DOMPurify.sanitize(marked.parse(txt)); if(historyArray&&txt){ const lastH=historyArray[historyArray.length-1]; if(!lastH || !(lastH.role==='model'&&lastH.parts[0]?.text===txt)){ historyArray.push({role:'model',parts:[{text:txt}]}); const pruned=pruneHistory(historyArray); if(pruned!==historyArray){ historyArray.length=0; historyArray.push(...pruned); }}} requestAnimationFrame(()=>{if(chatElements.messages.offsetHeight>0) chatElements.messages.scrollTop=chatElements.messages.scrollHeight;}); } }

      async function sendMessage(instanceId = null) {
          let chatInstance, chatElements = {}, historyArray, currentImgRef, relPath = null;
          let isFileChat = instanceId !== null && fileChatInstances[instanceId];
          let instanceType = isFileChat ? fileChatInstances[instanceId].type : null; // 'media' or 'document' or null

          // --- Determine context (Main Chat vs File Chat) ---
          if (isFileChat) {
              chatInstance = fileChatInstances[instanceId];
              chatElements = chatInstance.elements;
              historyArray = chatInstance.history;
              relPath = chatInstance.relPath;
              // currentImgRef = chatInstance; // We don't use the temporary attached image for file chat
          } else {
              // Main chat context
              chatElements = {
                  input: mainChatInput, sendButton: mainSendButton, modelSelect: mainModelSelect, messages: mainChatMessages,
                  imagePreviewArea: mainImagePreviewArea, imagePreview: mainImagePreview, imageFilename: mainImageFilename,
                  removeImageButton: mainRemoveImageButton, imageUploadButton: mainImageUploadButton, imageUploadInput: mainImageUploadInput,
                  micButton: mainMicButton, micStatus: mainMicStatus
              };
              historyArray = mainChatHistory;
              // <<< Directly use global mainAttachedImageData for main chat >>>
          }

          // --- Validate required elements ---
          if (!chatElements.input || !chatElements.modelSelect || !chatElements.sendButton || !chatElements.messages) {
              console.error("sendMessage Error: Missing critical chat elements for", instanceId || "main chat", chatElements);
              if(chatElements.sendButton) chatElements.sendButton.disabled = false;
              if(chatElements.micButton) chatElements.micButton.disabled = false; // Check existence
              return;
          }

          const msg = chatElements.input.value.trim();
          const model = chatElements.modelSelect.value;

          // --- Check if message is empty (allow sending if image is attached in MAIN chat) ---
          let mainChatImageAttached = !isFileChat && mainAttachedImageData; // <<< Directly check global variable
          if (!msg && !mainChatImageAttached && !isFileChat) {
              // Only return if message is empty AND it's the main chat without an image attached
              // File chat always proceeds to send the inherent image
              console.log("Empty message in main chat, returning.");
              return;
          }

          // --- Display User Message ---
          // For main chat, display attached image preview if present
          const userDisplayImageUrl = mainChatImageAttached ? chatElements.imagePreview.src : null;
          addMessageToChat(msg || ' ', 'user', chatElements, userDisplayImageUrl, historyArray);

          // --- Prepare Payload ---
          let payload;
          let fetchOpts = { method: 'POST' };

          // --- Disable buttons and clear input --- START
          chatElements.sendButton.disabled = true;
          if(chatElements.micButton) chatElements.micButton.disabled = true;
          if(chatElements.input) chatElements.input.value = ''; // Clear input after getting value

          if (mainChatImageAttached) {
              clearMainAttachedImage(); // Clear main preview
          } else if (isFileChat && chatElements.imagePreviewArea && instanceType === 'media') {
              // Only clear attached image preview for media file chats if one was temporarily attached (unlikely current flow)
              clearAttachedImage(instanceId);
          }
          // --- Disable buttons and clear input --- END

          try {
              addMessageToChat("...".padStart(3), 'assistant', chatElements, null, null); // Thinking indicator (don't add to history)
              const thinking = chatElements.messages.lastElementChild;

              if (isFileChat && instanceType === 'media' && relPath) {
                  // FILE CHAT (MEDIA): Always send image + message + history via FormData
                  console.log(`File chat (Media - ${instanceId}): Fetching image blob for ${relPath}`);
                  // Fetch the image Blob asynchronously
                  const drive = "{{ drive|urlencode }}";
                  const apiKey = "{{ api_key|urlencode }}";
                  const imageUrl = `/download?drive=${drive}&path=${encodeURIComponent(relPath)}&api_key=${apiKey}`;
                  const imageResponse = await fetch(imageUrl);
                  if (!imageResponse.ok) throw new Error(`Failed to fetch image for chat: ${imageResponse.statusText}`);
                  const imageBlob = await imageResponse.blob();

                  payload = new FormData();
                  payload.append('message', msg || '');
                  payload.append('model', model);
                  payload.append('history', JSON.stringify(historyArray.slice(0, -1))); // Send history *before* the current user msg
                  payload.append('image', imageBlob, fileChatInstances[instanceId].fileName); // Add the fetched image blob

                  fetchOpts.body = payload; // Set FormData as body
                  // Browser sets Content-Type automatically for FormData

              } else if (isFileChat && instanceType === 'document') {
                  // FILE CHAT (DOCUMENT): Send message + history + instanceId via JSON
                  console.log(`File chat (Document - ${instanceId}): Sending JSON payload.`);
                  payload = JSON.stringify({
                      message: msg || '',
                      model: model,
                      history: historyArray.slice(0, -1), // Send history *before* current user msg
                      instanceId: instanceId // <<< Include instanceId for RAG lookup
                  });
                  fetchOpts.body = payload;
                  fetchOpts.headers = { 'Content-Type': 'application/json' };

              } else if (isFileChat && instanceType === 'video') {
                  // <<< FILE CHAT (VIDEO): Send JSON payload, potentially flag for first message >>>
                  console.log(`File chat (Video - ${instanceId}): Sending JSON payload.`);
                  const isFirstVideoMessage = historyArray.length <= 1; // Check history length AFTER adding user message

                  payload = JSON.stringify({
                      message: msg || '', // Send user message
                      model: model,
                      history: historyArray.slice(0, -1), // Send history *before* current user msg
                      instanceId: instanceId,
                      processFirstVideoPart: isFirstVideoMessage // <<< Flag for backend
                  });
                  fetchOpts.body = payload;
                  fetchOpts.headers = { 'Content-Type': 'application/json' };
                  if (isFirstVideoMessage) {
                      console.log("Flagging this as the first video message for backend processing.");
                  }
              } else {
                  // MAIN CHAT: Send JSON or FormData based on attached image
                  // <<< Directly check global mainAttachedImageData >>>
                  if (mainAttachedImageData) { // If image data exists...
                      payload = new FormData(); // Create FormData
                      payload.append('message', msg || '');
                      payload.append('model', model);
                      payload.append('history', JSON.stringify(historyArray.slice(0, -1)));
                      payload.append('image', mainAttachedImageData); // <<< Append the global image data
                      fetchOpts.body = payload;
                      // >>> Browser sets Content-Type automatically for FormData <<<
                  } else { // If no image data...
                      payload = JSON.stringify({ message: msg, model: model, history: historyArray.slice(0, -1) });
                      fetchOpts.body = payload;
                      fetchOpts.headers = { 'Content-Type': 'application/json' };
                  }
                  // >>> Moved image clearing to AFTER successful send attempt in finally block for robustness <<<
                  // currentImgRef.attachedImageData = null;
              }

              // --- Make API Call ---
              console.log(`Sending chat request. IsFileChat: ${isFileChat}`, fetchOpts);
              const res = await fetch('/chat', fetchOpts);

              // --- Process Response ---
              if (thinking && chatElements.messages.contains(thinking)) chatElements.messages.removeChild(thinking);

              if (res.ok && res.headers.get('Content-Type')?.includes('text/event-stream')) {
                  const r = res.body.getReader();
                  const dec = new TextDecoder();
                  let buf = '', evTxt = '';
                  while (true) {
                      const { value, done } = await r.read();
                      if (done) { finalizeLastAssistantMessage(chatElements, historyArray); break; }
                      buf += dec.decode(value, { stream: true });
                      let b = buf.indexOf('\n\n');
                      while (b !== -1) {
                          evTxt = buf.substring(0, b); buf = buf.substring(b + 2);
                          if (evTxt.startsWith('event: end')) { finalizeLastAssistantMessage(chatElements, historyArray); break; }
                          if (evTxt.startsWith('data: ')) {
                              const j = evTxt.substring(6); try { const d = JSON.parse(j);
                                  if (d.response) updateLastAssistantMessage(d.response, chatElements);
                                  else if (d.error) { updateLastAssistantMessage(`\n[ERR: ${d.error}]`, chatElements); finalizeLastAssistantMessage(chatElements, historyArray); }
                              } catch (e) { console.error("SSE err:", e, "Data:", j); }
                          }
                          b = buf.indexOf('\n\n');
                      } if (evTxt && evTxt.startsWith('event: end')) break;
                  }
              } else {
                  // Handle non-streaming error
                  let eMsg = `Err: ${res.statusText}`;
                  try { const ed = await res.json(); eMsg = `Err: ${ed.error || res.statusText}`; } catch (e) { }
                  addMessageToChat(eMsg, 'assistant', chatElements, null, historyArray);
              }
          } catch (err) {
              // --- Handle Fetch/Processing Errors ---
              const t = chatElements.messages?.querySelector('.assistant-message:last-child');
              if (t && t.textContent === '...' && chatElements.messages.contains(t)) chatElements.messages.removeChild(t);
              console.error('Chat Err:', err);
              addMessageToChat(`Error occurred: ${err.message}`, 'assistant', chatElements, null, historyArray);
          } finally {
              // --- Re-enable buttons ---
              if(chatElements.sendButton) chatElements.sendButton.disabled = false;
              if(chatElements.micButton) chatElements.micButton.disabled = false; // Check existence
              // Clear main attached image explicitly (redundant but safe)
              if (!isFileChat && currentImgRef) currentImgRef.attachedImageData = null;
              // <<< Clear main attached image data AFTER the fetch attempt >>>
              // This ensures it's cleared even if the fetch fails immediately, 
              // but wasn't sent.
              if (!isFileChat && currentImgRef) {
                  clearMainAttachedImage(); // Use the existing function
              }
          }
      }

      // Image Handling (Main & File Specific)
      function handleMainImageFileSelect(e){const f=e.target.files[0];if(f&&f.type.startsWith('image/')){mainAttachedImageData=f;const r=new FileReader();r.onload=ev=>{if(mainImagePreview)mainImagePreview.src=ev.target.result;if(mainImageFilename)mainImageFilename.textContent=f.name;if(mainImagePreviewArea)mainImagePreviewArea.style.display='flex';};r.readAsDataURL(f);}else{clearMainAttachedImage();if(f)alert('Images only.');}if(mainImageUploadInput)mainImageUploadInput.value=null;}
      function clearMainAttachedImage(){mainAttachedImageData=null;if(mainImagePreview)mainImagePreview.src='#';if(mainImageFilename)mainImageFilename.textContent='';if(mainImagePreviewArea)mainImagePreviewArea.style.display='none';if(mainImageUploadInput)mainImageUploadInput.value=null;}
      function handleFileImageSelect(e,id){const i=fileChatInstances[id];if(!i?.elements.imagePreviewArea||!i?.elements.imagePreview)return;const f=e.target.files[0];if(f&&f.type.startsWith('image/')){i.attachedImageData=f;const r=new FileReader();r.onload=ev=>{i.elements.imagePreview.src=ev.target.result;if(i.elements.imageFilename)i.elements.imageFilename.textContent=f.name;i.elements.imagePreviewArea.style.display='flex';};r.readAsDataURL(f);}else{clearAttachedImage(id);if(f)alert('Images only.');}if(e.target)e.target.value=null;}
      function clearAttachedImage(id){const i=fileChatInstances[id];if(i){i.attachedImageData=null;if(i.elements.imagePreview)i.elements.imagePreview.src='#';if(i.elements.imageFilename)i.elements.imageFilename.textContent='';if(i.elements.imagePreviewArea)i.elements.imagePreviewArea.style.display='none';if(i.elements.imageUploadInput)i.elements.imageUploadInput.value=null;}}
      // Audio Handling (Main Chat Only For Now)
      async function toggleMainRecording(){if(!mainMicButton)return;if(isMainRecording){mainMediaRecorder?.stop();isMainRecording=false;mainMicButton.classList.remove('recording');mainMicButton.disabled=true;if(mainMicStatus)mainMicStatus.textContent='Processing...';}else{try{const s=await navigator.mediaDevices.getUserMedia({audio:true});mainMediaRecorder=new MediaRecorder(s);mainAudioChunks=[];mainMediaRecorder.ondataavailable=e=>mainAudioChunks.push(e.data);mainMediaRecorder.onstop=async()=>{const b=new Blob(mainAudioChunks,{type:'audio/ogg; codecs=opus'});mainAudioChunks=[];s.getTracks().forEach(t=>t.stop());await sendAudioData(b);mainMicButton.disabled=false;if(mainMicStatus)mainMicStatus.textContent='';};mainMediaRecorder.start();isMainRecording=true;mainMicButton.classList.add('recording');if(mainMicStatus)mainMicStatus.textContent='Recording...';if(mainChatInput)mainChatInput.disabled=true;if(mainSendButton)mainSendButton.disabled=true;if(mainImageUploadButton)mainImageUploadButton.disabled=true;}catch(err){console.error("Mic err:",err);if(mainMicStatus)mainMicStatus.textContent='Mic Error';alert(`Mic fail: ${err.message}`);isMainRecording=false;mainMicButton?.classList.remove('recording');if(mainChatInput)mainChatInput.disabled=false;if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainMicButton)mainMicButton.disabled=false;}}}
      async function sendAudioData(blob){if(!mainModelSelect)return;const m=mainModelSelect.value;const fd=new FormData();fd.append('audio',blob,'rec.ogg');fd.append('model',m);const els={messages:mainChatMessages};addMessageToChat("(Audio sent)",'user',els,null,mainChatHistory);try{addMessageToChat("...",'assistant',els,null,mainChatHistory);const t=els.messages.lastElementChild;const r=await fetch('/chat_audio',{method:'POST',body:fd});if(t&&els.messages.contains(t))els.messages.removeChild(t);if(!r.ok){let msg=`Aud Err: ${r.statusText}`;try{const d=await r.json();msg=`Aud Err: ${d.error||r.statusText}`; }catch(e){}addMessageToChat(msg,'assistant',els,null,mainChatHistory);}else{const d=await r.json();addMessageToChat(d.response,'assistant',els,null,mainChatHistory);}}catch(err){const t=els.messages?.querySelector('.assistant-message:last-child');if(t&&t.textContent==='...'&&els.messages.contains(t))els.messages.removeChild(t);console.error('Aud Chat Err:',err);addMessageToChat('Audio proc err.','assistant',els,null,mainChatHistory);}finally{if(mainChatInput)mainChatInput.disabled=false;if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainMicButton)mainMicButton.disabled=false;if(mainMicStatus)mainMicStatus.textContent='';}}
      // Main Chat Refresh
      function clearMainChat(){console.log("Clearing main chat...");if(mainChatMessages)mainChatMessages.innerHTML='';mainChatHistory=[];clearMainAttachedImage();if(mainChatInput)mainChatInput.value='';const els={messages:mainChatMessages};if(mainChatMessages)addMessageToChat("안녕하세요!",'assistant',els);if(mainSendButton)mainSendButton.disabled=false;if(mainImageUploadButton)mainImageUploadButton.disabled=false;if(mainChatInput)mainChatInput.disabled=false;if(mainMicButton){mainMicButton.disabled=false;if(isMainRecording){mainMediaRecorder?.stop();isMainRecording=false;mainMicButton.classList.remove('recording');}}if(mainMicStatus)mainMicStatus.textContent='';}

      // --- New Preview+Chat Instance Logic --- START
      function createPreviewChatInstance(instanceId, fileName, relPath, type) {
          console.log(`Creating instance ${instanceId} for ${fileName} (type: ${type})`); // Log type

          // Close mini player if opening a video preview
          if (type === 'video') {
              console.log("Video instance detected, attempting to hide mini player.");
              hideMiniPlayer();
          }

          const instanceDiv = document.createElement('div'); instanceDiv.id = instanceId; instanceDiv.className = 'preview-chat-instance';
          const header = document.createElement('div'); header.className = 'preview-chat-header';
          const title = document.createElement('span'); title.className = 'preview-chat-filename'; title.textContent = fileName; title.title = relPath;
          const closeBtn = document.createElement('button'); closeBtn.className = 'preview-chat-close-btn'; closeBtn.innerHTML = '&times;'; closeBtn.title = 'Close'; closeBtn.onclick = () => closePreviewChatInstance(instanceId);
          header.appendChild(title); header.appendChild(closeBtn);
          const contentDiv = document.createElement('div'); contentDiv.className = 'preview-chat-content';
          const previewArea = document.createElement('div'); previewArea.className = 'preview-area';
          const chatArea = document.createElement('div'); chatArea.className = 'chat-area'; chatArea.style.cssText='display:flex;flex-direction:column;height:100%;overflow:hidden;';

          // Clean up clonedElements definition
          const clonedElements = {
              previewArea: previewArea,
              modelSelect: null,
              messages: null,
              imageUploadInput: null, // For the new file input
              input: null,            // For the new text input
              sendButton: null,      // For the new send button
              processVideoButton: null // For the new process video button
          };

          // --- 1. Handle Model Selector and Messages Area --- START
          const modelSelectorContainer = mainChatContainer?.querySelector('.model-selector');
          const messagesDiv = document.createElement('div');

          if (modelSelectorContainer) {
              const clonedModelSelectorDiv = modelSelectorContainer.cloneNode(true);
              const selectElement = clonedModelSelectorDiv.querySelector('select');
              if (selectElement) {
                  selectElement.id = `${instanceId}-model-select`;
                  clonedElements.modelSelect = selectElement;
              }
              chatArea.appendChild(clonedModelSelectorDiv); // Append model selector
          } else {
              console.warn("Could not clone model selector.");
          }

          messagesDiv.id = `${instanceId}-messages`;
          messagesDiv.className = 'chat-messages';
          clonedElements.messages = messagesDiv;
          chatArea.appendChild(messagesDiv); // Append messages area
          // --- 1. Handle Model Selector and Messages Area --- END

          // --- 2. Create and Append File Upload Area --- START
          const fileUploadArea = document.createElement('div');
          fileUploadArea.className = 'file-upload-area'; // Use class for styling

          const fileInput = document.createElement('input');
          fileInput.type = 'file';
          fileInput.id = `${instanceId}-file-upload`;
          fileInput.accept = 'image/*'; // Keep accepting images for now
          fileInput.style.display = 'none'; // Hide the actual input

          const fileInputLabel = document.createElement('label');
          fileInputLabel.htmlFor = fileInput.id;
          fileInputLabel.textContent = '파일 선택';
          fileInputLabel.className = 'button-like-label'; // Add class for styling (ensure defined in CSS)

          const fileNameSpan = document.createElement('span');
          fileNameSpan.id = `${instanceId}-file-upload-filename`;
          fileNameSpan.textContent = '선택된 파일 없음';
          fileNameSpan.className = 'filename-display'; // Add class for styling (ensure defined in CSS)

          fileInput.onchange = (e) => {
              // Assuming handleFileImageSelect exists and is intended for file instances
              handleFileImageSelect(e, instanceId); 
              const file = e.target.files[0];
              fileNameSpan.textContent = file ? file.name : '선택된 파일 없음';
          };

          fileUploadArea.appendChild(fileInput);
          fileUploadArea.appendChild(fileInputLabel);
          fileUploadArea.appendChild(fileNameSpan);
          chatArea.appendChild(fileUploadArea); // Append below messages
          clonedElements.imageUploadInput = fileInput; // Store reference
          // --- 2. Create and Append File Upload Area --- END

          // --- 3. Create and Append Chat Input Area --- START
          const chatInputArea = document.createElement('div');
          chatInputArea.className = 'chat-input-area'; // Use class for styling
          chatInputArea.id = `${instanceId}-chat-input-area`

          const textInput = document.createElement('input');
          textInput.type = 'text';
          textInput.id = `${instanceId}-chat-input`;
          textInput.placeholder = '메시지를 입력하세요...';
          // Add necessary classes or styles if needed, e.g., to ensure it grows

          const sendButton = document.createElement('button');
          sendButton.id = `${instanceId}-send-button`;
          sendButton.textContent = '전송';
          // Add necessary classes or styles

          textInput.onkeypress = (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                  sendMessage(instanceId);
                  e.preventDefault();
              }
          };
          sendButton.onclick = () => sendMessage(instanceId);

          chatInputArea.appendChild(textInput);
          chatInputArea.appendChild(sendButton);
          chatArea.appendChild(chatInputArea); // Append below file upload area

          clonedElements.input = textInput; // Store reference
          clonedElements.sendButton = sendButton; // Store reference
          // --- 3. Create and Append Chat Input Area --- END

          // --- 4. Handle Video Processing Button --- START
          if (type === 'video') {
              console.log(`[createPreviewChatInstance] Creating video process button for ${instanceId}`);
              const processButton = document.createElement('button');
              processButton.id = `${instanceId}-process-video-button`;
              processButton.className = 'process-video-button'; // Apply specific styles
              processButton.innerHTML = '🎞️ 영상 처리 시작';
              processButton.onclick = () => handleProcessVideoButtonClick(instanceId, relPath, fileName);

              // Insert the button after the model selector
              const modelSelectorDiv = chatArea.querySelector('.model-selector');
              if (modelSelectorDiv) {
                   console.log("[createPreviewChatInstance] Inserting button after model selector.");
                   modelSelectorDiv.parentNode.insertBefore(processButton, modelSelectorDiv.nextSibling);
              } else {
                  // Fallback: append at the beginning of chatArea if model selector not found
                   console.warn("[createPreviewChatInstance] Model selector not found, prepending button to chatArea.");
                   chatArea.insertBefore(processButton, chatArea.firstChild);
              }
              clonedElements.processVideoButton = processButton; // Store reference

               // Disable input/send for video initially
               if (clonedElements.input) {
                   clonedElements.input.disabled = true;
                   clonedElements.input.placeholder = "영상 처리 시작 버튼을 눌러주세요."; // Changed placeholder
               }
               if (clonedElements.sendButton) clonedElements.sendButton.disabled = true;
               console.log(`[createPreviewChatInstance] Video chat controls disabled initially for ${instanceId}`);

          } // --- 4. Handle Video Processing Button --- END

          contentDiv.appendChild(previewArea);
          contentDiv.appendChild(chatArea);

          instanceDiv.appendChild(header);
          instanceDiv.appendChild(contentDiv);
          document.body.appendChild(instanceDiv);

          // <<< Linter Fix: Changed variable name from messagesDiv to messagesElement >>>
          const messagesElement = document.getElementById(`${instanceId}-messages`);
          if (!messagesElement) { console.error(`CRITICAL: Could not find messages div #${instanceId}-messages after creation!`); }
          // <<< Linter Fix: Assign the found element to clonedElements.messages >>>
          clonedElements.messages = messagesElement;

          fileChatInstances[instanceId] = { fileName: fileName, relPath: relPath, elements: clonedElements, history: [], attachedImageData: null, type: type };

          // Add initial message AFTER storing instance data
          if (clonedElements.messages) {
              const initialMsg = type === 'video' ? "영상 미리보기입니다. 분석하려면 [영상 처리 시작] 버튼을 누르세요." : "파일 미리보기입니다. 질문을 입력하세요.";
              addMessageToChat(initialMsg, 'assistant', { messages: clonedElements.messages }, null, fileChatInstances[instanceId].history);
          }

          // Disable input/send for video initially (redundant check, but safe)
          if (type === 'video') {
               if (clonedElements.input) clonedElements.input.disabled = true;
               if (clonedElements.sendButton) clonedElements.sendButton.disabled = true;
           }

          console.log(`Created instance: ${instanceId}`, fileChatInstances[instanceId]);
          loadPreviewContent(instanceId, relPath, fileName); // Load preview content LAST

          return clonedElements;
      }

      function closePreviewChatInstance(instanceId) {
          const instanceData = fileChatInstances[instanceId];

          if (instanceData) {
              const chatElements = instanceData.elements;
              const instanceType = instanceData.type;

              // Clear media elements if they exist
              const pA = chatElements?.previewArea;
              if(pA){const v=pA.querySelector('video,audio');if(v){v.pause();v.src='';}const i=pA.querySelector('iframe');if(i)i.src='about:blank';}

              // Remove the instance Div from the DOM
              const iD=document.getElementById(instanceId); if(iD)iD.remove(); else console.warn(`Instance div ${instanceId} not found`);

              // <<< If it was a document OR video instance, clear the backend cache >>>
              // Using the unified endpoint
              if (instanceType === 'document' || instanceType === 'video') {
                  console.log(`Clearing backend cache for ${instanceType} instance: ${instanceId}`);
                  const apiKey = "{{ api_key|urlencode }}";
                  fetch('/clear_instance_cache', {
                      method: 'POST',
                      headers: {
                          'Content-Type': 'application/json',
                          'X-Api-Key': apiKey // Send API key in header
                      },
                      body: JSON.stringify({ instanceId: instanceId })
                  })
                  .then(response => {
                      if (!response.ok) {
                          console.error(`Failed to clear cache for ${instanceId}. Status: ${response.status}`);
                          response.json().then(err => console.error("Cache clear error:", err.error)).catch(() => {});
                      } else {
                          console.log(`Backend cache cleared successfully for ${instanceId}`);
                      }
                  })
                  .catch(error => {
                      console.error(`Error calling /clear_instance_cache for ${instanceId}:`, error);
                  });
              }

              // Delete the instance data from the frontend store
              delete fileChatInstances[instanceId]; console.log(`Closed instance: ${instanceId}`);
          } else {
              console.warn(`Attempted to close non-existent instance: ${instanceId}`);
          }
      }

      function loadPreviewContent(instanceId, relPath, fileName) {
          const instance = fileChatInstances[instanceId];
          console.log(`[loadPreviewContent] Starting for instance: ${instanceId}, file: ${fileName}, path: ${relPath}`); // Debug Log
          if (!instance || !instance.elements?.previewArea) {
              console.error(`Preview load ERROR: Instance ${instanceId} or previewArea element missing in instance data.`);
              const paDiv = document.getElementById(instanceId)?.querySelector('.preview-area');
              if(paDiv) paDiv.innerHTML = '<span class="preview-placeholder">Error loading preview (Instance Data Missing).</span>';
              return;
          }
          const previewArea = instance.elements.previewArea;
          previewArea.innerHTML='<span class="preview-placeholder">Loading...</span>';

          const drv="{{ drive|urlencode }}"; const key="{{ api_key|urlencode }}";
          const ext=fileName.includes('.')?fileName.split('.').pop().toLowerCase():'';
          const vE=['mp4','webm','ogg','mov','avi','mkv','wmv','mpg','flv','3gpp'], aE=['mp3','wav','ogg','aac','flac'], iE=['jpg','jpeg','png','gif','bmp','webp','svg','ico'], tE=['py','js','html','css','java','c','cpp','cs','php','rb','go','rs','swift','kt','md','txt','json','xml','yaml','yml','ini','cfg','log','sh','bat','ps1','csv'], pE=['pdf'];
          let pUrl=null, pType=null;
          const encP=encodeURIComponent(relPath);

          console.log(`[loadPreviewContent] Determining type for ext: ${ext}`); // Debug Log
          if(vE.includes(ext)){pType='video';pUrl=`/stream/${encP}?drive=${drv}&api_key=${key}`;}else if(aE.includes(ext)){pType='audio';pUrl=`/stream/${encP}?drive=${drv}&api_key=${key}`;}else if(iE.includes(ext)){pType='image';pUrl=`/preview_image/${encP}?drive=${drv}&api_key=${key}`;}else if(tE.includes(ext)){pType='text';pUrl=`/preview_text/${encP}?drive=${drv}&api_key=${key}`;}else if(pE.includes(ext)){pType='pdf';pUrl=`/preview_pdf/${encP}?drive=${drv}&api_key=${key}`;} else { pType = 'unsupported'; }
          console.log(`[loadPreviewContent] Determined type: ${pType}, URL: ${pUrl}`); // Debug Log

          let el;
          if (pType !== 'unsupported' && pUrl) { // <<< Check pUrl is not null
              console.log(`[loadPreviewContent] Loading ${pType} preview for ${relPath} (${fileName}) in ${instanceId}`);
              if (pType==='video'){ el=document.createElement('video');el.controls=true;el.autoplay=false;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Video failed.</span>';}; } // Autoplay false initially for video
              else if (pType==='audio'){ el=document.createElement('audio');el.controls=true;el.autoplay=true;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Audio failed.</span>';}; }
              else if (pType==='image'){ el=document.createElement('img');el.alt=fileName;el.src=pUrl;el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Image failed.</span>';}; }
              else if ((pType==='text' || pType==='pdf') && pUrl){ el=document.createElement('iframe');el.style.cssText='width:100%;height:100%;border:none;';el.src=pUrl;el.onload=()=>console.log(`Iframe ${pType} loaded.`);el.onerror=()=>{previewArea.innerHTML='<span class="preview-placeholder">Preview failed.</span>';}; }

              if(el){ previewArea.innerHTML=''; previewArea.appendChild(el); }
              else { previewArea.innerHTML='<span class="preview-placeholder">Preview generation failed.</span>'; console.warn(`Preview element generation failed for type ${pType}, URL: ${pUrl}`); }
               } else {
              previewArea.innerHTML='<span class="preview-placeholder">Preview not supported for this file type.</span>';
              console.log(`Preview not supported for extension: ${ext}`);
          }
      }
      function closeAllPreviewChatInstances() { Object.keys(fileChatInstances).forEach(id => closePreviewChatInstance(id)); }
      // --- New Preview+Chat Instance Logic --- END

      // --- Initialize after DOM is ready ---
      document.addEventListener('DOMContentLoaded', function() {
          // --- Define Event Handlers within DOMContentLoaded ---
          // (These need to be defined before they are attached below)
          function handleTreeClick(e) {
              let target = e.target;
              // <<< Prevent clicks on toggle arrow from navigating >>>
              if (target.tagName.toLowerCase() === 'span' && target.classList.contains('toggle-arrow')) {
                   e.preventDefault();
                   toggleChildren(target);
                   return; // Stop further processing for arrow click
               }
              if (target.tagName.toLowerCase() === 'a' && target.classList.contains('folder-link')) {
                  e.preventDefault();
                  let li = target.parentElement;
                  let arrow = li.querySelector('.toggle-arrow');
                  if (arrow) toggleChildren(arrow); // Calls global toggleChildren
                  loadFileList(target.getAttribute('data-path')); // Calls global loadFileList
              }
          }

          function handleFileListSingleClick(e) {
              const fileEntry = e.target.closest('.file-entry');
              if (!fileEntry) return; // Click was not inside a file entry

              if (e.detail !== 1) return; // Ignore multi-clicks handled by the browser (like double-click selecting text)

              e.preventDefault(); // Prevent default behavior for this single click

              const isDir = fileEntry.dataset.isDir === 'true';
              const relPath = fileEntry.dataset.relPath;
              const fileName = fileEntry.querySelector('.file-name')?.textContent || fileEntry.querySelector('a')?.textContent || (relPath ? relPath.split('/').pop() : 'Unknown');

              if (isDir) {
                  // Handle folder navigation
                  console.log(`[Click] Folder: ${fileName}, Path: ${relPath}`);
                  // Find the actual link element to get the correct path (needed for '..')
                  const folderLink = fileEntry.querySelector('a');
                  const targetPath = folderLink?.getAttribute('href')?.split('path=')[1]?.split('&')[0];
                  if (targetPath !== undefined) {
                       loadFileList(decodeURIComponent(targetPath));
                  } else {
                      console.warn("Could not extract path from folder link:", folderLink?.getAttribute('href'));
                  }
              } else {
                  // Handle file click (Image, Video, Doc, Audio)
                  if (!relPath) { console.warn("[Click] Missing relPath for file:", fileName); return; }

                  const fileExt = fileName.includes('.') ? fileName.split('.').pop().toLowerCase() : '';
                  console.log(`[Click] File: ${fileName}, Ext: ${fileExt}, Path: ${relPath}`);

                  // Define File Type Categories
                  const llmImageExts=['png','jpg','jpeg','webp','heic','heif'];
                  const llmDocExts=['pdf','txt','md','py','js','html','css','json', 'csv', 'xml', 'yaml', 'yml', 'ini', 'cfg', 'log', 'sh', 'bat', 'ps1'];
                  const llmVideoExts=['mp4','mpeg','mov','avi','flv','mpg','webm','wmv','3gpp'];
                  const previewOnlyImageExts=['gif','bmp','svg','ico'];
                  const previewOnlyAudioExts=['mp3','wav','ogg','aac','flac'];
                  const msOfficeExts = ['xlsx', 'xls', 'docx', 'doc', 'pptx', 'ppt']; // MS Office types

                  console.log(`[Click] Checking extension against categories...`);

                  // Determine Action based on file type
                  if (llmImageExts.includes(fileExt) || llmVideoExts.includes(fileExt)) {
                      console.log(`[Click] Action: Opening Preview+Chat for LLM ${llmImageExts.includes(fileExt) ? 'Image' : 'Video'}`);
                      const instanceId = `file-chat-${instanceCounter++}`;
                      const instanceType = llmImageExts.includes(fileExt) ? 'media' : 'video';
                      const instanceElements = createPreviewChatInstance(instanceId, fileName, relPath, instanceType);

                      // <<< REMOVE automatic video processing call >>>
                      // if (instanceType === 'video') {
                      //     console.log(`[Click] Action: Calling initiateVideoProcessing for ${instanceId}`);
                      //     initiateVideoProcessing(instanceId, relPath, fileName, instanceElements.messages);
                      // }
                  } else if (llmDocExts.includes(fileExt)) {
                      console.log(`[Click] Action: Opening Preview+Chat for LLM Document`);
                      const instanceId = `file-chat-${instanceCounter++}`;
                      createPreviewChatInstance(instanceId, fileName, relPath, 'document');
                      console.log(`[Click] Action: Calling initiateDocumentProcessing for ${instanceId}`);
                      initiateDocumentProcessing(instanceId, relPath, fileName);
                  } else if (previewOnlyImageExts.includes(fileExt)) {
                      console.log(`[Click] Action: Opening standard modal preview for Image`);
                      const drive = "{{ drive|urlencode }}"; const apiKey = "{{ api_key|urlencode }}"; const encodedRelPath = encodeURIComponent(relPath);
                      const previewUrl = `/preview_image/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
                      showPreviewModal('image', previewUrl, fileName);
                  } else if (previewOnlyAudioExts.includes(fileExt)) {
                      console.log(`[Click] Action: Adding to Mini Player playlist`);
                      const drive = "{{ drive|urlencode }}"; const apiKey = "{{ api_key|urlencode }}"; const encodedRelPath = encodeURIComponent(relPath);
                      const streamUrl = `/stream/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
                      addToPlaylistAndPlay(streamUrl, fileName);
                  } else if (msOfficeExts.includes(fileExt)) {
                      console.log(`[Click] Action: MS Office file - No preview, prompt download?`);
                      // Maybe just log or offer download directly? For now, do nothing specific.
                      alert(`MS Office 파일 (${fileName}) 미리보기는 지원되지 않습니다. 필요시 다운로드하여 확인하세요.`);
                  } else {
                      console.log(`[Click] Action: Unsupported file type`);
                      alert(`지원하지 않는 파일 형식입니다: ${fileName}`);
                  }
              }
          }

          /* REMOVE Double Click Handler
          function handleFileListDoubleClick(e) {
              // ... (all logic removed) ...
          }
          */


          // --- Attach Event Listeners ---
          const treeElement = document.querySelector('.tree');
          if (treeElement) { treeElement.addEventListener('click', handleTreeClick); }
          else { console.warn("Tree element not found."); }

          // Attach File List Listener (Single Click Only)
          if (fileListContainer) {
              fileListContainer.addEventListener('click', handleFileListSingleClick);
              // fileListContainer.removeEventListener('dblclick', handleFileListDoubleClick); // Ensure double-click is removed if previously added
          } else { console.error("File list container (#file-list) not found."); }

          // Setup Main Chat Listeners
          setupMainChatListeners();

          // Initialize Main Chat UI
          if (mainChatMessages) { addMessageToChat("안녕하세요! 무엇을 도와드릴까요?", 'assistant', { messages: mainChatMessages }, null, mainChatHistory); }
          else { console.warn("Main chat messages container not found on init."); }

          // Initialize Mini Player
          initMiniPlayer(); // <<< ADD THIS CALL

          // Setup Search Listener
          const searchInput = document.getElementById('searchInput');
          let searchTimeout;
          if (searchInput) {
              searchInput.addEventListener('input', () => {
                  clearTimeout(searchTimeout);
                  searchTimeout = setTimeout(() => {
                      const q = searchInput.value.toLowerCase();
                      document.querySelectorAll('#file-list .file-entry').forEach(el => {
                          // Keep 'Up' directory visible
                          if (el.querySelector('.file-icon')?.textContent === '⤴️') {
                               el.style.display = 'flex';
                               return;
                           }
                           // Filter files/folders based on name
                          // Ensure this logic correctly handles files vs folders if needed
                          const nameEl = el.querySelector('.file-name') || el.querySelector('a.folder-link'); // Handle both files and folders
                          const name = nameEl ? nameEl.textContent.toLowerCase() : '';
                          el.style.display = name.includes(q) ? 'flex' : 'none';
                      });
                  }, 200);
              });
          } else { console.warn("Search input not found."); }

          // Setup Drag & Drop Listeners
          const dropArea = document.getElementById('drop-area');
          if (dropArea) {
              ['dragenter','dragover','dragleave','drop'].forEach(ev=>dropArea.addEventListener(ev,preventDefaults,false));
              ['dragenter','dragover'].forEach(ev=>dropArea.addEventListener(ev,()=>dropArea.classList.add('highlight'),false));
              ['dragleave','drop'].forEach(ev=>dropArea.addEventListener(ev,()=>dropArea.classList.remove('highlight'),false));
              dropArea.addEventListener('drop',handleDrop,false);
              // Prevent default browser drag/drop behavior on the body
              ['dragenter','dragover','drop'].forEach(ev=>document.body.addEventListener(ev,preventDefaults,false));

              const dropAreaFileInput = dropArea.querySelector('input[type="file"]');
              if (dropAreaFileInput) {
                  dropAreaFileInput.addEventListener('change', function() { if (this.files.length > 0) { handleFiles(this.files); } });
              }
          }

          // Initial File List Load
          const initialPath = new URLSearchParams(window.location.search).get('path') || '';
          loadFileList(initialPath);

      }); // ====== End DOMContentLoaded ======

      // --- >>> NEW Function to initiate document processing (Reverted) <<< ---
      async function initiateDocumentProcessing(instanceId, relPath, fileName) {
          const instance = fileChatInstances[instanceId];
          // <<< Enhanced Check for instance and elements >>>
          if (!instance || !instance.elements || !instance.elements.messages || !instance.elements.input || !instance.elements.sendButton) {
              console.error(`initDocProc Error: Instance (${instanceId}), its elements, or required sub-elements (messages, input, sendButton) are missing.`);
              // Try to add error message to main chat if instance messages missing
              const mainMessages = document.getElementById('chat-messages');
              if (mainMessages && (!instance || !instance.elements || !instance.elements.messages)) {
                  addMessageToChat(`오류: 문서 처리 UI 초기화 실패 (Instance ID: ${instanceId}). 콘솔을 확인하세요.`, 'assistant', { messages: mainMessages });
              } else if (instance?.elements?.messages) {
                  // If only input/button missing, add error to instance chat
                  addMessageToChat("오류: 문서 처리 UI 초기화 실패. 필수 채팅 요소(입력창/버튼)를 찾을 수 없습니다.", 'assistant', instance.elements);
              }
              return; // Stop execution if critical elements are missing
          }

          const chatElements = instance.elements;
          const processingMessageText = "문서 분석 및 벡터화 작업 중...";

          // Display processing message and disable input
          addMessageToChat(processingMessageText, 'assistant', chatElements, null, null); // <<< 수정: 히스토리에 추가 안 함, 클래스 제거
          const processingMsgElement = chatElements.messages.lastElementChild; // 참조 유지
          if (processingMsgElement) { // 스타일 직접 적용
               processingMsgElement.style.fontStyle = 'italic';
               processingMsgElement.style.opacity = '0.8';
          }

          chatElements.input.disabled = true;
          chatElements.sendButton.disabled = true;
          if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 내용 분석 중...</span>';

          try {
              const apiKey = "{{ api_key|urlencode }}";
              const response = await fetch('/process_document', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Api-Key': apiKey
                  },
                  body: JSON.stringify({
                instanceId: instanceId,
                relPath: relPath,
                fileName: fileName,
                drive: "{{ drive }}" // <<< 이 부분을 추가해주세요
            })
              });

              // <<< 처리중 메시지 제거 >>>
              if (processingMsgElement && chatElements.messages.contains(processingMsgElement)) {
                   processingMsgElement.remove();
              }

              if (response.ok) {
                  const result = await response.json();
                  console.log(`Document processing succeeded for ${instanceId}:`, result.message);
                  addMessageToChat(`✅ ${result.message || '문서 처리 완료.'} 이제 문서에 대해 질문할 수 있습니다.`, 'assistant', chatElements, null, instance.history);
                   if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 완료.</span>';
                   loadPreviewContent(instanceId, relPath, fileName);
              } else { // <<< 수정: 503 처리 제거, 일반 오류 처리 >>>
                  const result = await response.json().catch(() => ({ error: `서버 오류 (상태: ${response.status})` }));
                  console.error(`Document processing failed for ${instanceId}:`, result.error || response.statusText);
                  addMessageToChat(`❌ 문서 처리 실패: ${result.error || response.statusText}. 채팅 기능이 제한될 수 있습니다.`, 'assistant', chatElements, null, instance.history);
                   if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 실패.</span>';
              }

          } catch (error) { // <<< 수정: 처리중 메시지 제거 추가 >>>
              if (processingMsgElement && chatElements.messages.contains(processingMsgElement)) {
                   processingMsgElement.remove();
              }
              console.error(`Error calling /process_document for ${instanceId}:`, error);
              addMessageToChat(`❌ 문서 처리 요청 중 오류 발생: ${error.message}.`, 'assistant', chatElements, null, instance.history);
              if (chatElements.previewArea) chatElements.previewArea.innerHTML = '<span class="preview-placeholder">문서 분석 중 오류 발생.</span>';
          } finally {
              // <<< 수정: finally 블록에서 입력 활성화 >>>
              chatElements.input.disabled = false;
              chatElements.sendButton.disabled = false;
              console.log(`Input re-enabled for instance ${instanceId} after document processing attempt.`);
          }
      }

      // --- >>> NEW Functions for Video Processing <<< ---
      async function initiateVideoProcessing(instanceId, relPath, fileName, chatMessagesDiv) {
          // <<< REMOVE processing message creation and appending >>>
          // const processingMessage = document.createElement('div');
          // processingMessage.className = 'processing-message';
          // processingMessage.textContent = '영상 내용 분석 및 처리 요청 중...';
          // chatMessagesDiv.appendChild(processingMessage);

          const instance = fileChatInstances[instanceId];
          const chatElements = instance ? instance.elements : { messages: chatMessagesDiv };
          const processButton = instance?.elements?.processVideoButton;
          const loadingIntervalId = processButton?.dataset?.loadingIntervalId;

          // Function to stop loading animation and clear interval ID
          const stopLoadingAnimation = (buttonElement) => {
                if (loadingIntervalId) {
                    clearInterval(loadingIntervalId);
                    if (buttonElement) delete buttonElement.dataset.loadingIntervalId;
                }
            };

          if (!chatElements.messages) {
             console.error("initiateVideoProcessing: chatMessagesDiv is not valid or instance elements missing.");
             // <<< REMOVE redundant processing message removal >>>
             // if (processingMessage.parentNode === chatMessagesDiv) chatMessagesDiv.removeChild(processingMessage);
             stopLoadingAnimation(processButton); // Stop animation if started
             if (processButton) { processButton.disabled = false; processButton.textContent = "🎞️ 영상 처리 시작"; }
             return;
          }

          try {
              const response = await fetch('/process_video', {
                  method: 'POST',
                  headers: {
                      'Content-Type': 'application/json',
                      'X-Api-Key': "{{ api_key|urlencode }}"
                  },
                  body: JSON.stringify({ instanceId, relPath, fileName, drive: "{{ drive }}" })
              });

              // <<< REMOVE redundant processing message removal >>>
              // if (processingMessage.parentNode === chatMessagesDiv) chatMessagesDiv.removeChild(processingMessage);

              stopLoadingAnimation(processButton); // Stop animation after fetch completes

              if (response.ok) {
                  const result = await response.json();
                  console.log("Video processing initiated/completed:", result);
                  addMessageToChat(result.message || "✅ 비디오 처리가 완료되었습니다. 이제 질문할 수 있습니다.", 'assistant', chatElements, null, instance?.history);
                  if (processButton) { processButton.textContent = "처리 완료"; /* Keep disabled */ }
          } else {
                  const errorResult = await response.json().catch(() => ({ error: `영상 처리 중 서버 오류 (Status: ${response.status})` }));
                  const errorText = errorResult.error || `영상 처리 중 오류 발생 (Status: ${response.status})`;
                  console.error("Video processing error response:", errorResult);
                  addMessageToChat(`❌ 오류: ${errorText}`, 'assistant', chatElements, null, instance?.history);
                  if (processButton) { processButton.disabled = false; processButton.textContent = "🎞️ 처리 재시도"; }
              }
          } catch (error) {
              // <<< REMOVE redundant processing message removal >>>
              // if (processingMessage.parentNode === chatMessagesDiv) chatMessagesDiv.removeChild(processingMessage);
              stopLoadingAnimation(processButton); // Stop animation on catch
              console.error("Error calling /process_video:", error);
              addMessageToChat(`❌ 클라이언트 측 오류: ${error.message}`, 'assistant', chatElements, null, instance?.history);
              if (processButton) { processButton.disabled = false; processButton.textContent = "🎞️ 처리 재시도"; }
          } finally {
              // Re-enable input/send regardless of outcome
              if (instance && chatElements) {
                  if (chatElements.input) {
                       chatElements.input.disabled = false;
                       chatElements.input.placeholder = "메시지를 입력하세요...";
                   }
                  if (chatElements.sendButton) chatElements.sendButton.disabled = false;
              }
          }
      }

      // --- NEW: Handler for the process video button ---
       function handleProcessVideoButtonClick(instanceId, relPath, fileName) {
          const instance = fileChatInstances[instanceId];
          if (!instance || !instance.elements) {
              console.error("Cannot process video: Instance or elements not found for", instanceId);
              return;
          }

          const button = instance.elements.processVideoButton;
          const messagesDiv = instance.elements.messages;

          if (!button) {
              console.error("Process video button not found for", instanceId);
              return; // Cannot proceed without the button
          }

          button.disabled = true;
          // Start loading animation on the button
          let dotCount = 1;
          button.textContent = "처리 중.";
          const loadingInterval = setInterval(() => {
              dotCount = (dotCount % 3) + 1;
              button.textContent = `처리 중${`.`.repeat(dotCount)}`;
          }, 500); // Change dots every 500ms

          // Store interval ID on the button itself for easy access
          button.dataset.loadingIntervalId = loadingInterval;

          if (!messagesDiv) {
               console.error("Cannot process video: Messages div not found for", instanceId);
               // Stop animation and re-enable button if messagesDiv is missing
               clearInterval(loadingInterval);
               button.disabled = false; button.textContent = "🎞️ 영상 처리 시작";
               delete button.dataset.loadingIntervalId;
               return;
          }

          // Call the existing processing function
          initiateVideoProcessing(instanceId, relPath, fileName, messagesDiv);
      }

    </script>

    <!-- Mini Audio Player -->
    <div id="mini-audio-player" style="display: none;"> <!-- Base container -->
        <div class="mini-player-content">
            <span id="mini-player-title">Now Playing...</span>
            <div class="mini-player-controls">
                <button id="mini-player-prev" title="Previous (Not Implemented)">⏮️</button>
                <button id="mini-player-playpause" title="Play/Pause">▶️</button>
                <button id="mini-player-next" title="Next">⏭️</button>
                <!-- Volume Control -->
                <input type="range" id="mini-player-volume" title="Volume" min="0" max="1" step="0.05" value="1">
            </div>
            <div class="mini-player-progress-container">
                 <input type="range" id="mini-player-progress" value="0" min="0" max="100">
            </div>
             <span id="mini-player-time">0:00 / 0:00</span>
+             <!-- NEW Playlist UL -->
+             <ul id="mini-player-playlist" style="display: none;"></ul> <!-- Initially hidden -->
        </div>
        <button id="mini-player-close" title="Close Player">&times;</button>
    </div>

</body>
</html>