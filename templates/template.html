<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minwoo의 파일 탐색기</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/style.css">
  <!-- Add Marked.js library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Add DOMPurify library for sanitization -->
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.11/dist/purify.min.js"></script>
</head>
<body>
    <div class="sidebar">
      <div class="drive-selector">
        {% for drv in allowed_drives %}
          <a href="/?drive={{ drv }}&api_key={{ api_key }}" class="{% if drv == drive %}selected{% endif %}">{{ drv[:-2] }}</a>
        {% endfor %}
      </div>
      <h4>📁 탐색기</h4>
      <div class="tree">
        {{ tree_html|safe }}
      </div>
    </div>
    <div class="content">
      <div class="top-bar">
        <div class="nav-buttons">
          <button onclick="goBack()">⏪ 뒤로</button>
          <button onclick="goForward()">⏩ 앞으로</button>
        </div>
        <div class="search-bar">
          🔍 <input type="text" id="searchInput" oninput="searchFiles()" placeholder="파일명 검색...">
        </div>
        <div class="sort-buttons">
          <span>정렬:</span>
          {% set opposite_dir = 'desc' if sort_dir == 'asc' else 'asc' %}
          {% set name_dir = opposite_dir if sort_param == 'name' else 'asc' %}
          {% set date_dir = opposite_dir if sort_param == 'date' else 'asc' %}
          {% set size_dir = opposite_dir if sort_param == 'size' else 'asc' %}
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=name&dir={{ name_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'name' %}selected{% endif %}">
             이름 {% if sort_param == 'name' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=date&dir={{ date_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'date' %}selected{% endif %}">
             날짜 {% if sort_param == 'date' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
          <a href="/?drive={{ drive }}&path={{ current_path }}&sort=size&dir={{ size_dir }}&api_key={{ api_key }}" 
             class="{% if sort_param == 'size' %}selected{% endif %}">
             크기 {% if sort_param == 'size' %}{{ '▼' if sort_dir == 'desc' else '▲' }}{% endif %}
          </a>
        </div>
      </div>
      <div class="location-bar">
        <h3>📂 현재 위치 (드라이브: {{ drive[:-2] }}): {{ current_path or '/' }}</h3>
      </div>

      <!-- New Wrapper for File List and Chat -->
      <div class="content-wrapper">
        <!-- Existing File Content Area -->
        <div class="main-content">
            <div id="file-list" class="file-list">
                {% if is_search %}
                    <h2>Search Results for "{{ search_query }}" in {{ current_path or 'root' }}</h2>
                    {% include 'search_results.html' %}
                {% else %}
                    <h2>Files in {{ current_path or 'root' }}</h2>
                    {% include 'file_list.html' %}
                {% endif %}
            </div>
            <!-- 드래그 앤 드롭 업로드 영역 -->
            <div id="drop-area">
                <p>파일을 여기에 끌어다 놓으세요.</p>
                <p>또는 아래 버튼을 사용하여 파일을 선택할 수 있습니다.</p>
                <form method="POST" action="/upload?drive={{ drive }}&api_key={{ api_key }}&path={{ current_path }}" enctype="multipart/form-data">
                    <input type="file" name="file">
                    <button type="submit">업로드</button>
                </form>
                <div id="upload-progress"></div>
            </div>
        </div>

        <!-- New Chat Interface Area -->
        <div id="chat-container">
            <h4>💬 Gemini Chat</h4>
            <!-- Model Selector Dropdown -->
            <div class="model-selector">
                <label for="model-select">모델 선택:</label>
                <select id="model-select">
                    <option value="gemini-2.0-flash-lite" selected>gemini-2.0-flash-lite</option>
                    <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                    <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                </select>
            </div>
            <div id="chat-messages">
                <!-- Chat messages will appear here -->
            </div>
            <!-- Image preview area -->
            <div id="image-preview-area" style="display: none;">
                <img id="image-preview" src="#" alt="Image preview"/>
                <span id="image-filename"></span>
                <button id="remove-image-button" title="이미지 제거">&times;</button>
            </div>
            <!-- Mic status indicator -->
            <span id="mic-status"></span>
            <div id="chat-input-area">
                <!-- Hidden file input -->
                <input type="file" id="image-upload" accept="image/*">
                <!-- Image upload button -->
                <button id="image-upload-button" title="이미지 첨부">🖼️</button>
                <!-- Mic button -->
                <button id="mic-button" title="음성 입력">🎤</button>
                <input type="text" id="chat-input" placeholder="메시지를 입력하세요...">
                <button id="send-button">전송</button>
            </div>
        </div>
      </div>
      <!-- End New Wrapper -->

    </div> <!-- End .content -->

    <!-- Preview Modal Overlay -->
    <div id="preview-overlay" style="display: none;">
      <button id="preview-close-btn">&times;</button>
      <div id="preview-content"></div>
      <div id="preview-filename"></div>
    </div>

    <script>
      // --- Preview Modal Elements --- START
      const previewOverlay = document.getElementById('preview-overlay');
      const previewContent = document.getElementById('preview-content');
      const previewCloseBtn = document.getElementById('preview-close-btn');
      const previewFilename = document.getElementById('preview-filename');
      // --- Preview Modal Elements --- END

      // 좌측 트리의 폴더 링크 클릭 시: 페이지 새로고침 없이 자식 목록 토글 + 파일 리스트 AJAX 갱신
      document.addEventListener('DOMContentLoaded', function() {
        // 이벤트 위임을 사용하여 왼쪽 트리의 폴더 링크에 클릭 이벤트를 추가
        document.querySelector('.tree').addEventListener('click', function(e) {
          let target = e.target;
          if (target.tagName.toLowerCase() === 'a' && target.classList.contains('folder-link')) {
            e.preventDefault();
            // 토글: 해당 li의 toggle-arrow를 클릭한 효과
            let li = target.parentElement;
            let arrow = li.querySelector('.toggle-arrow');
            if (arrow) {
              toggleChildren(arrow);
            }
            // AJAX 호출로 오른쪽 파일 리스트 업데이트
            loadFileList(target.getAttribute('data-path'));
            // (원한다면 history.pushState로 URL도 갱신 가능)
          }
        });
      });
  
      function toggleChildren(el) {
        const li = el.parentElement;
        let childUl = li.querySelector('ul');
        if (!childUl) return; // ul이 없으면 아무것도 하지 않음

        // 만약 ul이 비어있다면 동적으로 자식 목록을 불러올 수 있습니다.
        if (childUl.innerHTML.trim() === "") {
                const path = li.querySelector('.folder-link').getAttribute('data-path');
                // AJAX 호출로 자식 폴더 목록을 불러온 후 childUl에 채워넣기 (예시)
                fetch(`/folder_children?drive={{ drive }}&api_key={{ api_key }}&path=${encodeURIComponent(path)}`)
                    .then(response => response.text())
                    .then(html => {
                        childUl.innerHTML = html;
                        childUl.style.display = 'block';
                        li.classList.add('expanded');
                        el.textContent = '🔽';
                    })
                    .catch(err => console.error('자식 폴더 불러오기 실패', err));
            } else {
                if (childUl.style.display === 'none' || childUl.style.display === '') {
                    childUl.style.display = 'block';
                    li.classList.add('expanded');
                    el.textContent = '🔽';
                } else {
                    childUl.style.display = 'none';
                    li.classList.remove('expanded');
                    el.textContent = '▶️';
                }
            }
        }

  
      function loadFileList(path) {
        const drive = "{{ drive }}";
        const api_key = "{{ api_key|urlencode }}";
        const sort = "{{ sort_param }}";
        const dir = "{{ sort_dir }}";
        fetch(`/filelist?drive=${encodeURIComponent(drive)}&api_key=${encodeURIComponent(api_key)}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}`)
          .then(response => response.text())
          .then(html => {
            document.getElementById('file-list').innerHTML = html;
            // 현재 위치 업데이트
            document.querySelector('.location-bar h3').textContent = `📂 현재 위치 (드라이브: ${drive.slice(0, -2)}): ${path || '/'}`;
            
            // 정렬 버튼 URL 업데이트
            const sortButtons = document.querySelectorAll('.sort-buttons a');
            const nameDir = sort === 'name' ? (dir === 'asc' ? 'desc' : 'asc') : 'asc';
            const dateDir = sort === 'date' ? (dir === 'asc' ? 'desc' : 'asc') : 'asc';
            const sizeDir = sort === 'size' ? (dir === 'asc' ? 'desc' : 'asc') : 'asc';
            
            sortButtons[0].href = `/?drive=${encodeURIComponent(drive)}&path=${encodeURIComponent(path)}&sort=name&dir=${nameDir}&api_key=${encodeURIComponent(api_key)}`;
            sortButtons[1].href = `/?drive=${encodeURIComponent(drive)}&path=${encodeURIComponent(path)}&sort=date&dir=${dateDir}&api_key=${encodeURIComponent(api_key)}`;
            sortButtons[2].href = `/?drive=${encodeURIComponent(drive)}&path=${encodeURIComponent(path)}&sort=size&dir=${sizeDir}&api_key=${encodeURIComponent(api_key)}`;
            
            // URL 업데이트 (선택 사항)
            history.pushState(null, '', `/?drive=${encodeURIComponent(drive)}&path=${encodeURIComponent(path)}&sort=${sort}&dir=${dir}&api_key=${encodeURIComponent(api_key)}`);
          })
          .catch(err => console.error('파일 목록 로드 실패', err));
      }

  
      function goBack() { history.back(); }
      function goForward() { history.forward(); }
  
      // 검색 기능 (디바운스 적용)
      const searchInput = document.getElementById('searchInput');
      let searchTimeout;
      function searchFiles() {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const input = searchInput.value.toLowerCase();
          document.querySelectorAll('.file-entry').forEach(el => {
            const name = el.textContent.toLowerCase();
            el.style.display = name.includes(input) ? 'flex' : 'none';
          });
        }, 200);
      }
  
      // 드래그 앤 드롭 업로드 관련 스크립트 (기존 코드와 동일)
      document.addEventListener('DOMContentLoaded', function() {
        const dropArea = document.getElementById('drop-area');
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          dropArea.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }
        ['dragenter', 'dragover'].forEach(eventName => {
          dropArea.addEventListener(eventName, () => dropArea.classList.add('highlight'), false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
          dropArea.addEventListener(eventName, () => dropArea.classList.remove('highlight'), false);
        });
        dropArea.addEventListener('drop', handleDrop, false);
        function handleDrop(e) {
          const dt = e.dataTransfer;
          const files = dt.files;
          handleFiles(files);
        }
        function handleFiles(files) {
          ([...files]).forEach(uploadFile);
        }
        function uploadFile(file) {
          const url = '/upload?drive={{ drive }}&api_key={{ api_key }}&path={{ current_path }}';
          const formData = new FormData();
          formData.append('file', file);
          const xhr = new XMLHttpRequest();
          xhr.open('POST', url, true);
          const progressContainer = document.getElementById('upload-progress');
          const progressItem = document.createElement('div');
          progressItem.className = 'progress-item';
          progressItem.innerHTML = `
            <div>${file.name} (${formatFileSize(file.size)})</div>
            <div class="progress-bar"></div>
          `;
          progressContainer.appendChild(progressItem);
          const progressBar = progressItem.querySelector('.progress-bar');
          xhr.upload.onprogress = function(e) {
            if (e.lengthComputable) {
              const percentComplete = (e.loaded / e.total) * 100;
              progressBar.style.width = percentComplete + '%';
            }
          };
          xhr.onload = function() {
            if (xhr.status >= 200 && xhr.status < 300) {
              progressBar.style.width = '100%';
              progressItem.style.backgroundColor = '#10b981';
              setTimeout(() => {
                progressItem.remove();
                if(progressContainer.children.length === 0) {
                  // 파일 업로드 후 현재 경로의 파일 목록을 다시 로드
                  loadFileList("{{ current_path }}");
                }
              }, 1000);
            } else {
              progressItem.style.backgroundColor = '#ef4444';
              progressItem.innerHTML += `<div style="color: #ef4444; margin-top: 8px;">업로드 실패: ${xhr.statusText}</div>`;
              setTimeout(() => progressItem.remove(), 3000);
            }
          };
          xhr.onerror = function() {
            progressItem.style.backgroundColor = '#ef4444';
            progressItem.innerHTML += `<div style="color: #ef4444; margin-top: 8px;">네트워크 오류가 발생했습니다.</div>`;
            setTimeout(() => progressItem.remove(), 3000);
          };
          xhr.send(formData);
        }
        function formatFileSize(bytes) {
          if (bytes === 0) return '0 Bytes';
          const k = 1024;
          const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
          const i = Math.floor(Math.log(bytes) / Math.log(k));
          return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        const fileInput = document.querySelector('input[type="file"]');
        fileInput.addEventListener('change', function() {
          if (this.files.length > 0) {
            handleFiles(this.files);
          }
        });
      });

      // --- Double-click preview logic (Modified for Modal) --- START
      document.getElementById('file-list').addEventListener('dblclick', function(e) {
        const fileEntry = e.target.closest('.file-entry');
        if (!fileEntry) return;
        const isDir = fileEntry.dataset.isDir === 'true';
        if (isDir) return;
        const relPath = fileEntry.dataset.relPath;
        if (!relPath) return;

        const drive = "{{ drive|urlencode }}";
        const apiKey = "{{ api_key|urlencode }}";
        const fileName = relPath.split('/').pop(); // Keep original case for display
        const fileExt = fileName.includes('.') ? fileName.split('.').pop().toLowerCase() : '';

        const videoExts = ['mp4', 'webm', 'ogg', 'mov', 'avi', 'mkv', 'wmv'];
        const audioExts = ['mp3', 'wav', 'ogg', 'aac', 'flac'];
        const imageExts = ['jpg', 'jpeg', 'png', 'gif', 'bmp', 'webp', 'svg', 'ico'];
        const textExts = ['py', 'js', 'html', 'css', 'java', 'c', 'cpp', 'cs', 'php',
                        'rb', 'go', 'rs', 'swift', 'kt', 'md', 'txt', 'json',
                        'xml', 'yaml', 'yml', 'ini', 'cfg', 'log', 'sh', 'bat', 'ps1', 'csv'];
        const pdfExts = ['pdf']; // Add PDF extension

        let previewUrl = null;
        let previewType = null;

        const encodedRelPath = encodeURIComponent(relPath);

        if (videoExts.includes(fileExt)) {
          previewType = 'video';
          previewUrl = `/stream/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
        } else if (audioExts.includes(fileExt)) {
          previewType = 'audio';
          previewUrl = `/stream/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
        } else if (imageExts.includes(fileExt)) {
          previewType = 'image';
          previewUrl = `/preview_image/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
        } else if (textExts.includes(fileExt)) {
          previewType = 'text';
          previewUrl = `/preview_text/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
        } else if (pdfExts.includes(fileExt)) { // Handle PDF
          previewType = 'pdf';
          previewUrl = `/preview_pdf/${encodedRelPath}?drive=${drive}&api_key=${apiKey}`;
        }

        if (previewUrl && previewType) {
          console.log(`Opening ${previewType} preview for ${relPath}: ${previewUrl}`);
          showPreviewModal(previewType, previewUrl, fileName);
        }
      });
      // --- Double-click preview logic --- END

      // --- Preview Modal Functions --- START
      function showPreviewModal(fileType, url, fileName) {
        // Clear previous content
        previewContent.innerHTML = '';
        previewFilename.textContent = fileName;

        let element;
        if (fileType === 'video') {
          element = document.createElement('video');
          element.controls = true;
          element.autoplay = true;
          element.style.maxWidth = '90vw';
          element.style.maxHeight = '80vh';
          element.src = url;
        } else if (fileType === 'audio') {
          element = document.createElement('audio');
          element.controls = true;
          element.autoplay = true;
          element.src = url;
        } else if (fileType === 'image') {
          element = document.createElement('img');
          element.style.maxWidth = '90vw';
          element.style.maxHeight = '80vh';
          element.style.display = 'block';
          element.style.margin = 'auto';
          element.alt = fileName;
          element.src = url;
        } else if (fileType === 'text') {
          element = document.createElement('iframe');
          element.style.width = '90vw';
          element.style.height = '80vh';
          element.style.border = 'none';
          element.style.backgroundColor = '#fff'; // Basic background for iframe
          element.src = url;
        } else if (fileType === 'pdf') { // Handle PDF with iframe
          element = document.createElement('iframe');
          element.style.width = '90vw';
          element.style.height = '80vh';
          element.style.border = 'none';
          element.style.backgroundColor = '#fff'; // Basic background for iframe
          element.src = url;
        }

        if (element) {
          previewContent.appendChild(element);
          previewOverlay.style.display = 'flex';
        }
      }

      function closePreviewModal() {
        previewOverlay.style.display = 'none';
        // Important: Stop video/audio/iframe content by removing the element source or the element itself
        previewContent.innerHTML = '';
        previewFilename.textContent = '';
      }

      // Close modal when clicking the close button or the overlay background
      previewCloseBtn.addEventListener('click', closePreviewModal);
      previewOverlay.addEventListener('click', function(e) {
        // Only close if the click is directly on the overlay (background), not the content inside
        if (e.target === previewOverlay) {
          closePreviewModal();
        }
      });
      // --- Preview Modal Functions --- END

      // --- Chat Functionality --- START
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendButton = document.getElementById('send-button');
      const modelSelect = document.getElementById('model-select');
      const imageUploadButton = document.getElementById('image-upload-button');
      const imageUploadInput = document.getElementById('image-upload');
      const imagePreviewArea = document.getElementById('image-preview-area');
      const imagePreview = document.getElementById('image-preview');
      const imageFilename = document.getElementById('image-filename');
      const removeImageButton = document.getElementById('remove-image-button');
      const micButton = document.getElementById('mic-button');
      const micStatus = document.getElementById('mic-status');

      // --- Chat History --- START
      let chatHistory = []; // Stores { role: 'user'/'model', parts: [{ text: '...' }] }
      const MAX_HISTORY_LENGTH = 20; // 10 turns (user + model)
      // Store attached image data
      let attachedImageData = null;

      function pruneHistory() {
          if (chatHistory.length > MAX_HISTORY_LENGTH) {
              // Remove the oldest two messages (one turn)
              chatHistory = chatHistory.slice(chatHistory.length - MAX_HISTORY_LENGTH);
          }
      }
      // --- Chat History --- END

      function addMessageToChat(message, sender, imageUrl = null) {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');
        messageElement.classList.add(sender === 'user' ? 'user-message' : 'assistant-message');

        // Render Markdown for assistant messages, sanitize output
        if (sender === 'assistant') {
            // Configure marked to add line breaks for newlines
            marked.setOptions({
                breaks: true
            });
            const rawHtml = marked.parse(message);
            messageElement.innerHTML = DOMPurify.sanitize(rawHtml);
        } else {
            // For user messages, just set text content
            messageElement.textContent = message;
        }

        // If it's a user message with an image URL, add image preview
        if (sender === 'user' && imageUrl) {
            const imgElement = document.createElement('img');
            imgElement.src = imageUrl;
            imgElement.alt = "Attached Image";
            imgElement.classList.add('attached-image-thumb');
            messageElement.appendChild(imgElement);
        }

        chatMessages.appendChild(messageElement);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        // Add to history
        const newHistoryEntry = { role: (sender === 'user' ? 'user' : 'model'), parts: [] };
        if (message) {
            newHistoryEntry.parts.push({ text: message });
        }
        // For user messages, add image placeholder/url if it existed for this turn
        // Note: We don't store the full image data in JS history for efficiency.
        // The backend uses the *currently* uploaded image.
        if (sender === 'user' && imageUrl) {
            // Optionally add a marker or the data URL (if small enough and needed for display)
            // For API context, backend relies on the currently uploaded image + text.
            // Let's just keep the text part for simplicity in JS history for now,
            // as the backend reconstructs the prompt correctly.
            // If context across multiple images becomes necessary, this needs revisiting.
            ;
        }

        // Only add if parts is not empty (e.g., avoid empty model responses)
        if (newHistoryEntry.parts.length > 0) {
            chatHistory.push(newHistoryEntry);
            pruneHistory(); // Keep history within limit
        }
      }

      // Function to update the last assistant message (for streaming)
      function updateLastAssistantMessage(textChunk) {
          let lastMessageElement = chatMessages.querySelector('.assistant-message:last-child');

          // If no last assistant message exists or it already contains final content,
          // create a new one for the stream.
          if (!lastMessageElement || lastMessageElement.dataset.streaming !== 'true') {
              lastMessageElement = document.createElement('div');
              lastMessageElement.classList.add('message', 'assistant-message');
              lastMessageElement.dataset.streaming = 'true'; // Mark as streaming
              chatMessages.appendChild(lastMessageElement);
          }

          // Append the chunk using Markdown rendering (or simple text)
          // Note: Appending raw HTML chunk by chunk can be tricky with Markdown.
          // It might be better to accumulate text and render at the end, or use a library that supports streaming markdown.
          // For now, let's just append text content for simplicity during streaming.
          // We can render the full markdown once the stream ends.
          lastMessageElement.textContent += textChunk;

          // Keep scrolled to bottom
          chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Function to finalize the last message (render Markdown and add to history)
      function finalizeLastAssistantMessage() {
           let lastMessageElement = chatMessages.querySelector('.assistant-message:last-child[data-streaming="true"]');
           if (lastMessageElement) {
               delete lastMessageElement.dataset.streaming; // Remove streaming marker
               const fullText = lastMessageElement.textContent; // Get accumulated text

               // Render final Markdown
               marked.setOptions({ breaks: true });
               const rawHtml = marked.parse(fullText);
               lastMessageElement.innerHTML = DOMPurify.sanitize(rawHtml);

               // Add the complete message to history
               chatHistory.push({ role: 'model', parts: [{ text: fullText }] });
               pruneHistory();

               chatMessages.scrollTop = chatMessages.scrollHeight; // Ensure scroll after render
           }
      }

      // Modify the fetch call slightly to handle headers conditionally
      async function sendMessage() {
        const message = chatInput.value.trim();
        const selectedModel = modelSelect.value;

        if (!message && !attachedImageData) return; // Don't send if both empty

        console.log("[Debug] sendMessage START - attachedImageData:", attachedImageData);

        // Add user message to chat UI
        const imagePreviewUrl = attachedImageData ? imagePreview.src : null;
        addMessageToChat(message || ' ', 'user', imagePreviewUrl); // Send space if only image

        // Prepare payload
        const payload = createChatPayload(message, selectedModel, chatHistory.slice(0, -1));

        console.log("[Debug] sendMessage AFTER createChatPayload - attachedImageData:", attachedImageData);

        // Clear input and image *after* preparing payload
        // Keep a reference to the image data for the current request
        const imageToSend = attachedImageData;
        chatInput.value = ''; // Clear text input
        // clearAttachedImage(); // Moved to finally block

        sendButton.disabled = true;

        try {
          // Add a temporary thinking message
          addMessageToChat("...", 'assistant');
          const thinkingMessageElement = chatMessages.lastElementChild;

          const fetchOptions = {
            method: 'POST',
            body: payload,
            // headers property will be added conditionally below
          };

          console.log("[Debug] Payload type:", typeof payload);

          // Set Content-Type ONLY for JSON payloads
          // For FormData, browser sets it automatically including the boundary
          if (!(payload instanceof FormData)) {
            console.log("[Debug] Setting Content-Type to application/json");
            fetchOptions.headers = { 'Content-Type': 'application/json' };
          }
          else {
            console.log("[Debug] Sending as FormData (no explicit Content-Type header)");
            // No headers property needed, browser handles it
          }

          console.log("[Debug] Fetch options:", fetchOptions); // Log the final options

          const response = await fetch('/chat', fetchOptions);

          // Remove thinking message
          if (thinkingMessageElement) {
             chatMessages.removeChild(thinkingMessageElement);
          }

          // --- Handle Streaming Response --- START
          if (response.ok && response.headers.get('Content-Type')?.includes('text/event-stream')) {
              const reader = response.body.getReader();
              const decoder = new TextDecoder();
              let buffer = '';
              let eventText = ''; // Declare eventText outside the inner loop

              while (true) {
                  const { value, done } = await reader.read();
                  if (done) {
                      console.log("Stream finished.");
                      finalizeLastAssistantMessage(); // Finalize last message render and history
                      break;
                  }

                  buffer += decoder.decode(value, { stream: true });

                  // Process buffer line by line for SSE events
                  let boundary = buffer.indexOf('\n\n');
                  while (boundary !== -1) {
                      eventText = buffer.substring(0, boundary); // Assign to outer variable
                      buffer = buffer.substring(boundary + 2);

                      if (eventText.startsWith('event: end')) {
                          console.log("Received end event from server.");
                          // Server signaled end, finalize might already be called by 'done'
                          finalizeLastAssistantMessage();
                          break; // Exit inner loop too
                      }
                      if (eventText.startsWith('data: ')) {
                          const jsonData = eventText.substring(6);
                          try {
                              const data = JSON.parse(jsonData);
                              if (data.response) {
                                  updateLastAssistantMessage(data.response);
                              } else if (data.error) {
                                  console.error("Streaming Error from Server:", data.error);
                                  updateLastAssistantMessage(`\n[오류: ${data.error}]`);
                                  // Should we finalize here or let 'done' handle it?
                                  // Let's finalize to ensure history is saved.
                                  finalizeLastAssistantMessage();
                              }
                          } catch (e) {
                              console.error("Error parsing SSE data:", e, "Data:", jsonData);
                          }
                      }
                       boundary = buffer.indexOf('\n\n');
                  }
                  if (eventText && eventText.startsWith('event: end')) break; // Exit outer loop if end event received
              }
          } else { // Handle non-streaming response (e.g., initial error)
               if (!response.ok) {
                   let errorMsg = `Error: ${response.statusText}`;
                   try {
                       const errorData = await response.json();
                       errorMsg = `Error: ${errorData.error || response.statusText}`;
                   } catch (e) { /* Ignore if response is not JSON */ }
                   addMessageToChat(errorMsg, 'assistant');
               } else {
                  // Unexpected non-streaming success?
                  const data = await response.json();
                  addMessageToChat(data.response || "(예상치 못한 응답 형식)", 'assistant');
               }
          }
          // --- Handle Streaming Response --- END

        } catch (error) {
            // Catch network errors or other JS errors during fetch/streaming
            // Remove thinking message even on network error
            const thinkingMessageElement = chatMessages.querySelector('.assistant-message:last-child'); // Find it again
            if (thinkingMessageElement && thinkingMessageElement.textContent === '...') {
                chatMessages.removeChild(thinkingMessageElement);
            }
            console.error('Chat Error:', error);
            addMessageToChat('오류가 발생했습니다. 다시 시도해주세요.', 'assistant');
        } finally {
            // Clear the image AFTER the request is complete (success or error)
            clearAttachedImage();
            sendButton.disabled = false; // Re-enable button
        }
      }

      // Event listeners
      sendButton.addEventListener('click', sendMessage);
      chatInput.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
          // Prevent sending if shift+enter is pressed (for potential multiline input later)
          if (!event.shiftKey) {
            sendMessage();
            event.preventDefault(); // Prevent default newline in input
          }
        }
      });
      // Image Upload listeners
      imageUploadButton.addEventListener('click', () => {
          if (isRecording) return; // Prevent action while recording
          imageUploadInput.click(); // Trigger hidden file input
      });

      imageUploadInput.addEventListener('change', handleImageFileSelect);
      removeImageButton.addEventListener('click', clearAttachedImage);

      // --- Audio Recording Logic --- START
      let mediaRecorder;
      let audioChunks = [];
      let isRecording = false;

      micButton.addEventListener('click', toggleRecording);

      async function toggleRecording() {
          if (isRecording) {
              // Stop recording
              mediaRecorder.stop();
              isRecording = false;
              micButton.classList.remove('recording');
              micButton.disabled = true; // Disable while processing
              micStatus.textContent = '처리 중...';
          } else {
              // Start recording
              try {
                  const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                  mediaRecorder = new MediaRecorder(stream);

                  mediaRecorder.ondataavailable = event => {
                      audioChunks.push(event.data);
                  };

                  mediaRecorder.onstop = async () => {
                      const audioBlob = new Blob(audioChunks, { type: 'audio/ogg; codecs=opus' }); // Or detect type
                      audioChunks = []; // Reset chunks
                      stream.getTracks().forEach(track => track.stop()); // Release microphone
                      await sendAudioData(audioBlob);
                      micButton.disabled = false; // Re-enable after processing
                      micStatus.textContent = ''; // Clear status
                  };

                  mediaRecorder.start();
                  isRecording = true;
                  micButton.classList.add('recording');
                  micStatus.textContent = '녹음 중...';
                  // Disable other inputs while recording
                  chatInput.disabled = true;
                  sendButton.disabled = true;
                  imageUploadButton.disabled = true;

              } catch (err) {
                  console.error("마이크 접근 오류:", err);
                  micStatus.textContent = '마이크 오류';
                  alert(`마이크 접근에 실패했습니다: ${err.message}`);
              }
          }
      }

      async function sendAudioData(audioBlob) {
          const selectedModel = modelSelect.value;
          const formData = new FormData();
          formData.append('audio', audioBlob, 'recorded_audio.ogg'); // Add filename
          formData.append('model', selectedModel);

          addMessageToChat("(음성 입력 전송됨)", 'user'); // Placeholder message

          try {
              addMessageToChat("...", 'assistant');
              const thinkingMessageElement = chatMessages.lastElementChild;

              const response = await fetch('/chat_audio', {
                  method: 'POST',
                  body: formData // FormData sets Content-Type automatically
              });

              // Remove thinking message
              if (thinkingMessageElement) {
                  chatMessages.removeChild(thinkingMessageElement);
              }

              if (!response.ok) {
                  let errorMsg = `오디오 처리 오류: ${response.statusText}`;
                  try {
                      const errorData = await response.json();
                      errorMsg = `오디오 처리 오류: ${errorData.error || response.statusText}`;
                  } catch (e) { /* Ignore */ }
                  addMessageToChat(errorMsg, 'assistant');
              } else {
                  const data = await response.json();
                  addMessageToChat(data.response, 'assistant');
              }
          } catch (error) {
              const thinkingMessageElement = chatMessages.querySelector('.assistant-message:last-child');
              if (thinkingMessageElement && thinkingMessageElement.textContent === '...') {
                  chatMessages.removeChild(thinkingMessageElement);
              }
              console.error('Audio Chat Error:', error);
              addMessageToChat('오디오 처리 중 오류 발생.', 'assistant');
          } finally {
             // Re-enable inputs after processing
             chatInput.disabled = false;
             sendButton.disabled = false;
             imageUploadButton.disabled = false;
             micButton.disabled = false;
             micStatus.textContent = '';
          }
      }
      // --- Audio Recording Logic --- END

      function handleImageFileSelect(event) {
          const file = event.target.files[0];
          if (file && file.type.startsWith('image/')) {
              attachedImageData = file; // Store the file object

              // Show preview
              const reader = new FileReader();
              reader.onload = function(e) {
                  imagePreview.src = e.target.result;
                  imageFilename.textContent = file.name;
                  imagePreviewArea.style.display = 'flex';
              }
              reader.readAsDataURL(file);
          } else {
              // Clear if invalid file selected
              clearAttachedImage();
              alert('이미지 파일만 선택해주세요.');
          }
          // Reset input value so the same file can be selected again after removal
          imageUploadInput.value = null;
      }

      function clearAttachedImage() {
          attachedImageData = null;
          imagePreview.src = '#';
          imageFilename.textContent = '';
          imagePreviewArea.style.display = 'none';
          imageUploadInput.value = null; // Also clear the input
      }

      // Helper function to create payload (JSON or FormData)
      function createChatPayload(message, model, history) {
          console.log("[Debug] createChatPayload ENTER - attachedImageData:", attachedImageData);
          if (attachedImageData) {
              console.log("[Debug] createChatPayload: Creating FormData.");
              const formData = new FormData();
              formData.append('message', message || ''); // Send empty string if no text
              formData.append('model', model);
              formData.append('history', JSON.stringify(history)); // History as JSON string
              formData.append('image', attachedImageData); // Add image file
              // Content-Type header is set automatically by browser for FormData
              return formData;
          } else {
              console.log("[Debug] createChatPayload: Creating JSON string.");
              // Standard JSON payload for text-only messages
              const body = JSON.stringify({ message, model, history });
              return body; // Just return body, headers handled in fetch
          }
      }

      // --- Chat Functionality --- END

    </script>
</body>
</html>